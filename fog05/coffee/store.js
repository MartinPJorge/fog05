// Generated by CoffeeScript 2.1.1
(function() {
  // This file contain the implementation of a proxy Store for interacting
  // with fog05. Through this API any JS-based runtime can interact with the
  // distributed store used by fog05. As such it can access the full power of
  // fog05
  var Create, Get, NOK, Notify, OK, Observe, Put, Runtime, Store, Value, exports, fog05, root, z_;

  root = this;

  z_ = coffez;

  fog05 = {};

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = fog05;
    }
    exports.fog05 = fog05;
  } else {
    root.fog05 = fog05;
  }

  fog05.VERSION = "0.1.0";

  // Commands
  OK = class OK {
    constructor(cid, sid1, rest) {
      this.cid = cid;
      this.sid = sid1;
      this.rest = rest;
    }

    show() {
      var args;
      args = this.rest.reduce(function(a, x) {
        return a + " " + x;
      });
      return `OK ${this.cid} ${this.sid} ${this.args}`;
    }

  };

  NOK = class NOK {
    constructor(cid, sid1) {
      this.cid = cid;
      this.sid = sid1;
    }

    show() {
      return `NOK ${this.cid} ${this.sid}`;
    }

  };

  Create = class Create {
    constructor(sid1, root1, home, cache_size) {
      this.sid = sid1;
      this.root = root1;
      this.home = home;
      this.cache_size = cache_size;
    }

    show() {
      return `create ${this.sid} ${this.root} ${this.home} ${this.cache_size}`;
    }

  };

  Put = class Put {
    constructor(sid1, uri, value1) {
      this.sid = sid1;
      this.uri = uri;
      this.value = value1;
    }

    show() {
      return `put ${this.sid} ${this.uri} ${this.value}`;
    }

  };

  Get = class Get {
    constructor(sid1, uri) {
      this.sid = sid1;
      this.uri = uri;
    }

    show() {
      return `get ${this.sid} ${this.uri}`;
    }

  };

  Observe = class Observe {
    constructor(sid1, cookie1, uri) {
      this.sid = sid1;
      this.cookie = cookie1;
      this.uri = uri;
    }

    show() {
      return `observe ${this.sid} ${this.uri}`;
    }

  };

  Notify = class Notify {
    constructor(sid1, cookie1, uri, value1) {
      this.sid = sid1;
      this.cookie = cookie1;
      this.uri = uri;
      this.value = value1;
    }

    show() {
      return `notify ${this.sid} ${this.uri} ${this.value}`;
    }

  };

  Value = class Value {
    constructor(sid1, key1, value1) {
      this.sid = sid1;
      this.key = key1;
      this.value = value1;
    }

    show() {
      return `value ${this.sid} ${this.key} ${this.value}`;
    }

  };

  ({
    parseOK: function(ts) {
      if (ts.length > 2) {
        return z_.Some(new OK(ts[1], ts[2], ts.slice(3)));
      } else {
        return z_.None;
      }
    },
    parseNOK: function(ts) {
      if (ts.length > 2) {
        return z_.Some(new NOK(ts[1], ts[2]));
      } else {
        return z_.None;
      }
    },
    parseNotify: function(ts) {
      if (ts.length > 4) {
        return z_.Some(new Notify(ts[1], ts[2], ts[3], tr[4]));
      } else {
        return z_.None;
      }
    },
    parseValue: function(ts) {
      if (ts.length === 3) {
        return new Value(ts[1], ts[2], z_.None);
      } else if (ts.length > 3) {
        return z_.Some(new Value(ts[1], ts[2], z_.Some(ts[3])));
      } else {
        return z_.None;
      }
    },
    parse: function(cmd) {
      var t, tokens, x;
      tokens = (function() {
        var i, len, ref, results;
        ref = cmd.split(' ')(x !== '');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(x);
        }
        return results;
      })();
      if (tokens.length === 0) {
        return z_.None;
      } else {
        t = tokens[0];
        if (t === 'OK') {
          return parseOK(tokens);
        } else if (t === 'NOK') {
          return parseNOK(tokens);
        } else if (t === 'notify') {
          return parseNotify(tokens);
        } else if (t === 'value') {
          return parseValue(tokens);
        } else {
          return z_.None;
        }
      }
    }
  });

  
  // The `Runtime` maintains the connection with the server, re-establish the connection if dropped and mediates
  // the `DataReader` and `DataWriter` communication.
  Runtime = class Runtime {
    // Creates a new fog05 runtime
    constructor(url1) {
      // Establish a connection with the dscript.play server
      this.connect = this.connect.bind(this);
      // Disconnects, withouth closing, a `Runtime`. Notice that there is a big difference between disconnecting and
      // closing a `Runtime`. The a disconnected `Runtime` can be reconnected and retains state across
      // connection/disconnections. On the other hand, once closed a `Runtime` clears up all current state.
      this.disconnect = this.disconnect.bind(this);
      // Close the fog05 runtime and as a consequence all the `DataReaders` and `DataWriters` that belong to this runtime.
      this.close = this.close.bind(this);
      this.isConnected = this.isConnected.bind(this);
      this.isClosed = this.isClosed.bind(this);
      this.handleMessage = this.handleMessage.bind(this);
      this.url = url1;
      this.onclose = function(evt) {};
      this.onconnect = function() {};
      this.ondisconnect = function(evt) {};
      this.connected = false;
      this.closed = true;
      this.cookieId = 0;
      this.pendingWebSock = z_.None;
      this.webSock = z_.None;
      this.storeHandlersMap = {};
    }

    generateEntityId() {
      var id;
      id = this.cookieId;
      this.cookieId += 1;
      return id;
    }

    connect() {
      if (this.connected === false) {
        console.log(`Connecting to: ${url}`);
        this.pendingWebSock = new z_.Some(new WebSocket(url));
        this.pendingWebSock.map(((s) => {
          return s.onopen = () => {
            console.log('Connected to: ' + this.uri);
            this.webSock = this.pendingWebSock;
            this.connected = true;
            // We may need to re-establish dropped data connection, if this connection is following
            // a disconnection.
            return this.onconnect();
          };
        }));
        this.pendingWebSock.map(((s) => {
          return s.onclose = (evt) => {
            console.log(`The server at ${this.uri} seems to have dropped the connection.`);
            this.connected = false;
            this.webSock.close();
            this.closed = true;
            this.webSock = z_.None;
            return this.ondisconnect(evt);
          };
        }));
        return this.pendingWebSock.map(((s) => {
          return s.onmessage = (msg) => {
            return this.handleMessage(msg);
          };
        }));
      } else {
        return console.log("Warning: Trying to connect an already connected Runtime");
      }
    }

    disconnect() {
      this.connected = false;
      this.webSock.map(function(s) {
        return s.close();
      });
      return this.ondisconnect();
    }

    close() {
      return this.webSock.map(((s) => {
        s.close();
        return this.onclose();
      }));
    }

    isConnected() {
      return this.connected;
    }

    isClosed() {
      return this.closed;
    }

    handleMessage(s) {
      var cmd, handlers, msg;
      msg = s.data;
      console.log('received' + msg);
      cmd = parse(msg);
      handlers = this.storeHandlersMap;
      return cmd.map((function(c) {
        var h;
        h = handlers[c.cid];
        if ((h != null) === true) {
          return h(c);
        }
      }));
    }

    send(msg) {
      return this.webSock.map(function(s) {
        return s.send(msg);
      });
    }

    register(sid, handlers) {
      return this.storeHandlersMap[sid] = handlers;
    }

  };

  root.fog05.Runtime = Runtime;

  Store = class Store {
    constructor(runtime1, sid1, home, root1, cache_size) {
      var cmd;
      this.runtime = runtime1;
      this.sid = sid1;
      this.home = home;
      this.root = root1;
      this.cache_size = cache_size;
      this.getTable = {};
      this.obsTable = {};
      this.handlers = {
        OK: function(cmd) {
          return self.handleOK(cmd);
        },
        NOK: function(cmd) {
          return self.handleNOK(cmd);
        },
        notify: function(cmd) {
          return self.handleNotify(cmd);
        },
        value: function(cmd) {
          return self.handleValue(cmd);
        }
      };
      runtime.register(this.sid, this.handlers);
      cmd = new Create(this.sid, this.home, this.root, this.cache_size);
      this.runtime.send(cmd.show());
    }

    put(key, value) {
      var cmd;
      cmd = new Put(this.sid, this.key, this.value);
      return this.runtime.send(cmd.show());
    }

    get(fun) {
      return function(key) {
        var cmd;
        this.getTable[key] = fun;
        cmd = new Get(this.sid, key);
        return this.runtime.send(cmd.show());
      };
    }

    observe(key, cookie, fun) {
      var cmd;
      this.obsTable[cookie] = fun;
      cmd = new Observe(this.cid, this.cookie, this.uri);
      return this.runtime.send(cmd.show());
    }

    handleOK(cmd) {
      return console.log('Store Handling OK');
    }

    handleValue(cmd) {
      var fun;
      fun = this.getTable[cmd.key];
      if ((fun != null) === true) {
        return fun(cmd.key, cmd.value);
      }
    }

    handleNotify(cmd) {
      var fun;
      console.log('Store Handling Notify');
      fun = this.obsTable[cmd.cookie];
      if ((fun != null) === true) {
        return fun(cmd.key.cmd.value);
      }
    }

    handleNOK(cmd) {
      return console.log('Store Handling NOK');
    }

  };

}).call(this);

//# sourceMappingURL=store.js.map
