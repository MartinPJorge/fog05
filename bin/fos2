import sys

from click import pass_obj, pass_context
from jsonschema import validate, ValidationError
from fog05.DStore import *
from fog05 import Schemas
import signal
from fog05.fosagent import FosAgent
import time
import uuid
import argparse
import daemon as dmn

##
## TODO: sostitute all string with variables in store interaction
##


class FOSStore(object):
    def __init__(self, aroot, droot, home):
        self.aroot = aroot #'dfos://<sys-id>'
        self.ahome = str('%s/%s' % (aroot, home)) #str('dfos://<sys-id>/%s' % self.uuid)

        self.droot = droot  # 'dfos://<sys-id>'
        self.dhome = str('%s/%s' % (droot, home))  # str('dfos://<sys-id>/%s' % self.uuid)

        self.actual = DStore(home, self.aroot, self.ahome, 1024)
        self.desidered = DStore(home, self.droot, self.dhome, 1024)


class FOSCli(object):

    def __init__(self):
        self.agent = None
        self.store = None
        self.aroot = 'afos://<sys-id>'
        self.droot = 'dfos://<sys-id>'
        self.uuid = str(uuid.uuid4())

    def __initialize(self):
        self.store = FOSStore(self.aroot, self.droot, self.uuid)

    def __read_file(self, file_path):
        with open(file_path, 'r') as f:
            data = f.read()
        return data

    def __send_add_network(self, node_uuid, manifest):

        manifest.update({'status':'add'})
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        all_plugins = json.loads(self.store.actual.get(uri)).get('plugins')
        print(all_plugins)
        nws = [x for x in all_plugins if x.get('type') == 'network']
        if len(nws) == 0:
            print("No network plugin loaded on node, aborting")
            return
        brctl = nws[0]  # will use the first plugin

        uri = str('dfos://<sys-id>/%s/plugins' % node_uuid)
        print(uri)

        json_data = json.dumps(manifest)
        uri = str('dfos://<sys-id>/%s/network/%s/networks/%s' %
                  (node_uuid, brctl.get('uuid'), manifest.get('uuid')))
        r = self.store.desidered.put(uri, json_data)
        if r is None:
            print("Resolved failed")
        elif r:
            print("network added")

    def __send_remove_network(self, node_uuid, net_id):

        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        all_plugins = json.loads(self.store.actual.get(uri)).get('plugins')
        nws = [x for x in all_plugins if x.get('type') == 'network']
        print("locating brctl plugin")
        search = [x for x in nws if 'brctl' in x.get('name')]
        print(search)
        if len(search) == 0:
            print("Plugin was not loaded")
            exit(0)
        else:
            brctl = search[0]

        uri = str('dfos://<sys-id>/%s/network/%s/networks/%s#status=remove' % (node_uuid, brctl.get('uuid'), net_id))
        self.store.desidered.dput(uri)

    def __catch_signal(self, signal, frame):
        if signal == 2:
            if self.agent is not None:
                self.agent.stop()
                time.sleep(1)
            exit(0)

    def __start_node(self, plugin_path, debug):
        signal.signal(signal.SIGINT, self.__catch_signal)
        self.agent = FosAgent(debug=debug, plugins_path=plugin_path)
        self.agent.run()
        while True:
            time.sleep(100)

    def __search_plugin_by_name(self, name, node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        all_plugins = self.store.actual.get(uri)
        if all_plugins is None:
            print("Cannot get plugin")
            return None
        #all_plugins = all_plugins
        all_plugins = json.loads(all_plugins).get('plugins')
        search = [x for x in all_plugins if name in x.get('name')]
        if len(search) == 0:
            return None
        else:
            return search[0]

    def __get_entity_handler_by_uuid(self, node_uuid, entity_uuid):
        uri = str('afos://<sys-id>/%s/runtime/*/entity/%s' % (node_uuid, entity_uuid))
        all = self.store.actual.resolveAll(uri)
        print(all)
        return all


    def __send_define_entity(self, node_uuid, manifest):
        manifest.update({'status': 'define'})
        handler = None
        t = manifest.get('type')

        try:
            if t == "vm":
                handler = self.__search_plugin_by_name('KVM', node_uuid)
                validate(manifest.get("entity_data"), Schemas.vm_schema)
            elif t == "container":
                handler = self.__search_plugin_by_name('LXD', node_uuid)
                validate(manifest.get("entity_data"), Schemas.container_schema)
            elif t == "native":
                handler = self.__search_plugin_by_name('native', node_uuid)
                validate(manifest.get("entity_data"), Schemas.native_schema)
            elif t == "ros2":
                handler = self.__search_plugin_by_name('ros2', node_uuid)
                validate(manifest.get("entity_data"), Schemas.ros2_schema)
            elif t == "usvc":
                print("microservice not yet")
            else:
                print("type not recognized")

            if handler is None:
                print("error on plugin for this type of entity")
                exit(-1)
        except ValidationError as ve:
            print("Manifest is not correct")
            print("%s" % ve.message)
            exit(-1)

        entity_uuid = manifest.get("uuid")
        entity_definition = manifest
        json_data = json.dumps(entity_definition)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s' % (node_uuid, handler.get('uuid'), entity_uuid))
        self.store.desidered.put(uri, json_data)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler.get('uuid'), entity_uuid))
            entity_info = json.loads(self.store.actual.get(uri))
            if entity_info is not None and entity_info.get("status") == "defined":
                break

    def __send_undefine_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=undefine' % (node_uuid, handler, entity_uuid))
        self.store.desidered.dput(uri)

    def __send_configure_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=configure' % (node_uuid, handler, entity_uuid))
        self.store.desidered.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler, entity_uuid))
            container_info = json.loads(self.store.actual.get(uri))
            if container_info is not None and container_info.get("status") == "configured":
                break

    def __send_clean_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=clean' % (node_uuid, handler, entity_uuid))
        self.store.desidered.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler, entity_uuid))
            container_info = json.loads(self.store.actual.get(uri))
            if container_info is not None and container_info.get("status") == "cleaned":
                break

    def __send_run_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=run' % (node_uuid, handler, entity_uuid))
        self.store.desidered.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler, entity_uuid))
            container_info = json.loads(self.store.actual.get(uri))
            if container_info is not None and container_info.get("status") == "run":
                break

    def __send_stop_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=stop' % (node_uuid, handler, entity_uuid))
        self.store.desidered.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler, entity_uuid))
            container_info = json.loads(self.astore.get(uri))
            if container_info is not None and container_info.get("status") == "stop":
                break

    def __send_pause_entity(self, node_uuid, entity_uuid):
        pass

    def __send_resume_entity(self, node_uuid, entity_uuid):
        pass

    def __send_migrate_entity(self, node_uuid, entity_uuid, destination_uuid):
        pass

    def start(self, plugins, verbose, daemon):
        if plugins:
            sys.path.append(os.path.abspath(plugins))
            if daemon:
                print('Forking in backgroud')
                pid = '/tmp/fos.pid'
                print('PID file %s' % pid)
                with dmn.DaemonContext(pidfile=pid, umask=0):
                    self.__start_node(plugins, verbose)
            else:
                self.__start_node(plugins, verbose)
        else:
            print('You should specify plugin path!!')

    def node(self,node_list, uuid, plugin_action, action, manifest, plugin_uuid):
        #print(node_list,uuid,plugin_action,action,manifest,plugin_uuid)
        if node_list:
            uri = str('afos://<sys-id>/*/')
            print(uri)
            nodes = self.store.actual.resolveAll(uri)  ## se below for information on this
            print(nodes)
            return
        if uuid is not None and plugin_action is False:
            uri = str('afos://<sys-id>/%s/' % uuid)  ## this is because the resolver return a tuple with
            # value and version
            print("Uri: %s" % uri)
            node = self.store.actual.get(uri)
            if node is not None and len(node) > 0:
                node = json.loads(node)
                print('+-------------------------------------------------------+')
                print('| UUID : %s \t\t|' % node.get('uuid'))
                print('| Name: %s \t\t|' % node.get('name'))
                print('+-------------------------------------------------------+')
            else:
                print("Node not found!!")
            return
        if uuid is not None and plugin_action is True:
            if action == 'add':
                print("Adding plugin from %s to %s" % (manifest, uuid))
                #manifest = json.loads(self.__read_file(manifest))
                uri = str('dfos://<sys-id>/%s/plugins' % uuid)
                self.store.desidered.dput(uri, self.__read_file(manifest))
            if action == 'remove':
                print("Removing plugin %s from %s" % (plugin_uuid, uuid))


    def network(self,nw_list, node_uuid, add, remove, manifest, net_uuid):
        #print(nw_list, node_uuid, add, remove, manifest, net_uuid)
        if nw_list:
            print("This should list all networks")
            return
        if node_uuid is not None:
            if add and manifest is not None:
                manifest = json.loads(self.__read_file(manifest))
                try:
                    validate(manifest, Schemas.network_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")
                self.__send_add_network(node_uuid, manifest)
                print("Network UUID is %s" % manifest.get('uuid'))
                return
            if remove and net_uuid is not None:
                self.__send_remove_network(node_uuid, net_uuid)
                return


    def entity(self, en_list, action, node_uuid, manifest, entity_uuid, dest_node):
        #print(en_list,action,node_uuid,manifest,entity_uuid,dest_node)
        if en_list:
            print("This should print all entities in the system")
            return
        if node_uuid is None: return
        if action == 'define' and manifest is not None:
            manifest = json.loads(self.__read_file(manifest))
            try:
                validate(manifest, Schemas.entity_schema)
            except ValidationError as ve:
                print("Manifest is not correct")
                print("%s" % ve.message)
                return
            print("manifest Ok")
            self.__send_define_entity(node_uuid, manifest)
            print("Entity %s defined" % manifest.get('uuid'))
            return
        if entity_uuid is None: return
        if action == 'undefine':
            self.__send_undefine_entity(node_uuid, entity_uuid)
            print("Entity %s undefined" % entity_uuid)
            return
        if action == 'configure':
            self.__send_configure_entity(node_uuid, entity_uuid)
            print("Entity %s configured" % entity_uuid)
        if action == 'clean':
            self.__send_clean_entity(node_uuid, entity_uuid)
            print("Entity %s cleaned" % entity_uuid)
        if action == 'run':
            print("Entity %s started" % entity_uuid)
            self.__send_run_entity(node_uuid, entity_uuid)
        if action == 'stop':
            self.__send_stop_entity(node_uuid, entity_uuid)
            print("Entity %s stopped" % entity_uuid)
        if action == 'pause':
            self.__send_pause_entity(node_uuid, entity_uuid)
            print("Pause sended")
        if action == 'resume':
            self.__send_resume_entity(node_uuid, entity_uuid)
            print("Resume sended")
        if action == 'migrate' and dest_node is not None:
            print("Not yet...")
            pass

    def manifest(self, type, manifest):
        manifest = json.loads(self.__read_file(manifest))
        if type == 'entity':
            t = manifest.get('type')
            try:
                if t == "vm":
                    validate(manifest.get("entity_data"), Schemas.vm_schema)
                elif t == "container":
                    validate(manifest.get("entity_data"), Schemas.container_schema)
                elif t == "native":
                    validate(manifest.get("entity_data"), Schemas.native_schema)
                elif t == "ros2":
                    validate(manifest.get("entity_data"), Schemas.ros2_schema)
                elif t == "usvc":
                    print("microservice not yet")
                else:
                    print("type not recognized")
            except ValidationError as ve:
                print("Manifest is not correct")
                print("%s" % ve.message)
                exit(-1)
        if type == 'network':
            try:
                validate(manifest, Schemas.network_schema)
            except ValidationError as ve:
                print("Manifest is not correct")
                print("%s" % ve.message)
                exit(-1)
        if type == "application":
            try:
                validate(manifest, Schemas.app_schema)
            except ValidationError as ve:
                print("Manifest is not correct")
                print("%s" % ve.message)
                exit(-1)

        print("Manifest seems ok!")
        return



    def main(self):
        parser = argparse.ArgumentParser(description='Fog05 | The Fog-Computing IaaS')
        subparsers = parser.add_subparsers(dest='cmd')

        ##START CMD

        parser_start = subparsers.add_parser('start')
        parser_start.add_argument('-p', '--plugins', required=True, type=str, default=False, help='plugin path')
        parser_start.add_argument('-v', '--verbose', action='store_true', default=False, help='Verbose output')
        parser_start.add_argument('-d', '--daemon', action='store_true', default=False, help='Run as a daemon')


        ## NODE CMD
        parser_node = subparsers.add_parser('node')

        node_grp = parser_node.add_mutually_exclusive_group(required=True)

        node_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all nodes')
        node_grp.add_argument('-u', '--uuid',  type=str, default=None, help='Node uuid')

        parser_node.add_argument('-p','-plugin', action='store_true', default=False, help='enable action on plugin',
                                 dest='plugin')

        node_plugin_grp = parser_node.add_mutually_exclusive_group(required=False)
        node_plugin_grp.add_argument('-a', '--add', action='store_true', default=False, help='add plugin')
        node_plugin_grp.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin')

        #parser_node.add_argument('-a', '--add', nargs='?', type=bool, default=False, help='add plugin', dest='action')
        #parser_node.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin',
        #                         dest='action')

        parser_node.add_argument('-m', '--manifest', type=str, default=None, help='plugin manifest')
        parser_node.add_argument('-pu', '--puuid', type=str, default=None, help='plugin uuid')



        ## NETWORK CMD
        parser_network = subparsers.add_parser('network')
        network_grp = parser_network.add_mutually_exclusive_group(required=True)

        network_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        network_grp.add_argument('-a','--add', action='store_true', help='add network')
        network_grp.add_argument('-r','--remove', action='store_true', help='remove network')

        parser_network.add_argument('-m', '--manifest', type=str, default=None, help='network manifest')
        parser_network.add_argument('-nu', '--nuuid', type=str, default=None, help='network uuid')
        parser_network.add_argument('-u', '--uuid', type=str, default=None, required=True, help='node uuid')

        ## ENTITY CMD
        parser_entity = subparsers.add_parser('entity')
        entity_grp = parser_entity.add_mutually_exclusive_group(required=True)

        entity_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        entity_grp.add_argument('-a', '--add', action='store_true', help='add entity')
        entity_grp.add_argument('-r', '--remove', action='store_true', help='remove entity')
        entity_grp.add_argument('--define', action='store_true', help='define entity')
        entity_grp.add_argument('--undefine', action='store_true', help='remove entity')
        entity_grp.add_argument('--configure', action='store_true', help='configure entity')
        entity_grp.add_argument('--clean', action='store_true', help='clean entity')
        entity_grp.add_argument('--run', action='store_true', help='run entity')
        entity_grp.add_argument('--stop', action='store_true', help='stop entity')
        entity_grp.add_argument('--pause', action='store_true', help='pause entity')
        entity_grp.add_argument('--resume', action='store_true', help='resume entity')
        entity_grp.add_argument('--migrate', action='store_true', help='migrate entity')

        parser_entity.add_argument('-m', '--manifest', type=str, default=None, help='entity manifest')
        parser_entity.add_argument('-eu', '--euuid', type=str, default=None, help='entity uuid')
        parser_entity.add_argument('-u', '--uuid', type=str, default=None, required=True, help='node uuid')
        parser_entity.add_argument('-du', '--duuid', type=str, default=None, help='destination node uuid')

        ## MANIFEST CMD
        parser_manifest = subparsers.add_parser('manifest')
        manifest_grp = parser_manifest.add_mutually_exclusive_group(required=True)
        manifest_grp.add_argument('-n', '--network', action='store_true', help='network manifest')
        manifest_grp.add_argument('-e', '--entity', action='store_true', help='entity manifest')
        manifest_grp.add_argument('-a', '--application', action='store_true', help='application manifest')
        parser_manifest.add_argument('manifest', type=str, default=None, help='manifest path')


        kwargs = vars(parser.parse_args())
        print(kwargs)

        if kwargs['cmd'] == 'start':
            self.start(kwargs['plugins'], kwargs['verbose'], kwargs['daemon'])

        elif kwargs['cmd'] == 'manifest':
            type = ''
            if kwargs['network'] is True: type = 'network'
            if kwargs['entity'] is True: type = 'entity'
            if kwargs['application'] is True: type = 'application'
            self.manifest(type, kwargs['manifest'])

        else:
            self.__initialize()
            if kwargs['cmd'] == 'node':
                action = ''
                if kwargs['add'] is True: action = 'add'
                elif kwargs['remove'] is True: action = 'remove'
                self.node(kwargs['list'], kwargs['uuid'], kwargs['plugin'], action, kwargs['manifest'],
                          kwargs['puuid'])
            elif kwargs['cmd'] == 'network':
                self.network(kwargs['list'],kwargs['uuid'], kwargs['add'], kwargs['remove'], kwargs['manifest'],
                             kwargs['nuuid'])
            elif kwargs['cmd'] == 'entity':

                action = ''
                if kwargs['add'] is True: action = 'add'
                if kwargs['remove'] is True: action = 'remove'
                if kwargs['define'] is True: action = 'define'
                if kwargs['undefine'] is True: action = 'undefine'
                if kwargs['configure'] is True: action = 'configure'
                if kwargs['clean'] is True: action = 'clean'
                if kwargs['run'] is True: action = 'run'
                if kwargs['stop'] is True: action = 'stop'
                if kwargs['pause'] is True: action = 'pause'
                if kwargs['resume'] is True: action = 'resume'
                if kwargs['migrate'] is True: action = 'migrate'

                self.entity(kwargs['list'], action, kwargs['uuid'], kwargs['manifest'], kwargs['euuid'],
                            kwargs['duuid'])
            else:
                print("Error check your command line!!")
                exit(-1)


if __name__ == '__main__':
        c = FOSCli()
        c.main()