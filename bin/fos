#!/usr/bin/env python3

import argparse
## cli using webserver
import asyncio
import os
import re
import signal
import tempfile
import time

import psutil
import websockets
from jsonschema import validate, ValidationError

from fog05 import Schemas
from fog05.DStore import *
from fog05.fosagent import FosAgent

if os.name == 'posix':
    import daemon as dmn


##
## TODO: sostitute all string with variables in store interaction
##


class WSStore(object):
    def __init__(self, sid, root, home, host):
        self.sid = sid
        self.root = root
        self.home = home
        self.host = host
        #self.websocket = websockets.connect('ws://{}:9669'.format(host))

    async def create(self):
        cmd = 'create {} {} {} 1024'.format(self.sid, self.root, self.home)
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def put(self, uri, val):
        cmd = 'put {} {} {}'.format(self.sid, uri, val)
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def dput(self, uri, value=None):
        cmd = 'dput {} {}'.format(self.sid, uri)
        if value is not None:
            cmd = str('{} {}'.format(cmd, value))
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def get(self, uri):
        cmd = 'get {} {}'.format(self.sid, uri)

        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1]
        if infos in ['', ' ']:
            return None
        infos = infos.replace(' ', '')
        if infos is not None and infos != '':
            return infos
        else:
            return None

    async def getAll(self, uri):
        cmd = 'aget {0} {1}'.format(self.sid, uri)
        values=[]
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            nodes_list = infos.split('|')
            for e in nodes_list:
                i = e.split('@')
                if len(i)>1:
                    if i[1] is not None and i[1] not in ['',' ', 'None']:
                        v = []
                        v.append(i[0])
                        v.append(''.join(i[1:]))
                        values.append(tuple(v))

        return tuple(values)

    async def resolveAll(self, uri):
        cmd = 'aresolve {0} {1}'.format(self.sid, uri)
        values=[]
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            nodes_list = infos.split('|')
            for e in nodes_list:
                i = e.split('@')
                if len(i)>1:
                    if i[1] is not None and i[1] not in ['',' ', 'None']:
                        v = []
                        v.append(i[0])
                        v.append(''.join(i[1:]))
                        values.append(tuple(v))

        return tuple(values)

    async def remove(self, uri):
        cmd = 'remove {} {}'.format(self.sid, uri)
        async with websockets.connect('ws://{}:9669'.format(self.host)) as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False


class FOSStore(object):
    def __init__(self, aroot, droot, home, host):
        self.aroot = aroot #'dfos://<sys-id>'
        self.ahome = str('{}/{}'.format(aroot, home)) #str('dfos://<sys-id>/{}' % self.uuid)

        self.droot = droot  # 'dfos://<sys-id>'
        self.dhome = str('{}/{}'.format(droot, home))  # str('dfos://<sys-id>/{}' % self.uuid)

        self.actual = WSStore('a{}'.format(home), self.aroot, self.ahome, host)
        self.desired = WSStore('d{}'.format(home), self.droot, self.dhome, host)

    def close(self):
        pass
        #self.actual.close()
        #self.desidered.close()


class FOSCli(object):

    def __init__(self,host):
        #self.agent = None
        self.store = None
        self.aroot = 'afos://<sys-id>'
        self.droot = 'dfos://<sys-id>'
        self.uuid = 'localhost'
        self.host = host

        self.server_file = os.path.join(tempfile.gettempdir(), 'dstore_server.pid')
        self.server_file_out = os.path.join(tempfile.gettempdir(), 'dstore_server.out')
        self.server_file_err = os.path.join(tempfile.gettempdir(), 'sdstore_erver.err')

        # TODO should be removed after wrapping implemented
        self.websocket = None
        self.asid = 'alocalhost'
        self.dsid = 'dlocalhost'



    def __initialize(self):


        flag = False

        if os.path.isfile(self.server_file) is False:
            f = open(self.server_file, 'w')
            f_err = open(self.server_file_err, 'w')
            f_out = open(self.server_file_out, 'w')
            cmd_splitted = 'f05ws'.split()
            p = psutil.Popen(cmd_splitted, stdout=f_out, stderr=f_err)
            f.write(str(p.pid))
            f.close()
            flag = True
        else:
            with open(self.server_file,'r') as f:
                pid = int(f.read())
                f.close()
            if not psutil.pid_exists(pid):
                f = open(self.server_file, 'w')
                f_err = open(self.server_file_err,'w')
                f_out = open(self.server_file_out, 'w')
                cmd_splitted = 'f05ws'.split()
                p = psutil.Popen(cmd_splitted, stdout=f_out,stderr=f_err)
                f.write(str(p.pid))
                f.close()
                flag = True



            #cmd = 'f05ws'
            #import



        #self.websocket = websockets.connect('ws://localhost:9669')

        self.store = FOSStore(self.aroot, self.droot, self.uuid, self.host)
        if flag:
            time.sleep(5)
            asyncio.get_event_loop().run_until_complete(self.store.desired.create())
            time.sleep(1)
            asyncio.get_event_loop().run_until_complete(self.store.actual.create())
            time.sleep(1)

        #if len(self.store.actual.discovered_stores) == 0:
        #    time.sleep(3)
        #if len(self.store.desidered.discovered_stores) == 0:
        #    time.sleep(3)

    def __read_file(self, file_path):
        with open(file_path, 'r') as f:
            data = f.read()
        return data

    def exit(self, exit_code):
        if self.store is not None:
            self.store.close()
        exit(exit_code)

    async def __get_all_node_plugin(self,node_uuid):
        uri = str('afos://<sys-id>/{}/plugins'.format(node_uuid))
        response = await self.store.actual.get(uri)
        # cmd = 'get {} {}'.format(self.asid, uri)
        # async with self.websocket as ws:
        #     await ws.send(cmd)
        #     response = await ws.recv()
        #     response = response.split(uri)[-1].replace(' ', '')
        if response is not None and response != '':
            return json.loads(response).get('plugins')
        else:
            return None

    async def __send_add_network(self, node_uuid, manifest):

        manifest.update({'status':'add'})
        all_plugins = await self.__get_all_node_plugin(node_uuid)
        if all_plugins is None:
            print('Error on receive plugin from node')
            return
        nws = [x for x in all_plugins if x.get('type') == 'network']
        if len(nws) == 0:
            print('No network plugin loaded on node, aborting')
            return
        brctl = nws[0]  # will use the first plugin

        json_data = json.dumps(manifest).replace(' ','')
        uri = str('dfos://<sys-id>/{}/network/{}/networks/{}'.format(node_uuid, brctl.get('uuid'), manifest.get('uuid')))

        res = await self.store.desired.put(uri, json_data)
        if res:
            print("Network {} added to {}".format(manifest.get('uuid'), node_uuid))
        else:
            print("Error on adding network")

        # cmd = 'put {0} {1} {2}'.format(self.sid, uri, json_data)
        # async with self.websocket as ws:
        #     await ws.send(cmd)
        #     response = await ws.recv()
        # print('{0} NETWORK {1} ADD'.format(response,manifest.get('uuid')))
        #
        # response = response.split(' ')
        # if response[0] == 'OK':
        #     print('Network UUID is {}' % manifest.get('uuid'))
        # elif response[0] == 'NOK':
        #     print("Error on adding network")
        # else:
        #     print("Wrong response for dStore server")
        #r = self.store.desidered.put(uri, json_data)
        #if r is None:
        #    print('Resolved failed')
        #elif r:
        #    print('network added')

    async def __send_remove_network(self, node_uuid, net_id):

        all_plugins = await self.__get_all_node_plugin(node_uuid)
        if all_plugins is None:
            print('Error on receive plugin from node')
            return
        nws = [x for x in all_plugins if x.get('type') == 'network']
        #print('locating brctl plugin')
        search = [x for x in nws if 'brctl' in x.get('name')]
        #print(search)
        if len(search) == 0:
            print('Plugin was not loaded')
            return
        else:
            brctl = search[0]

        uri = str('dfos://<sys-id>/{}/network/{}/networks/{}'.format(node_uuid, brctl.get('uuid'), net_id))
        res = await self.store.desired.remove(uri)
        if res:
            print("Network {} removed from {}".format(net_id, node_uuid))
        else:
            print("Error on adding network")

        # cmd = 'remove {0} {1}'.format(self.sid, uri)
        # async with self.websocket as ws:
        #     await ws.send(cmd)
        #     response = await ws.recv()
        # print('{0} NETWORK {1} REMOVE'.format(response, net_id))
        #
        # response = response.split(' ')
        # if response[0] == 'OK':
        #     print('Network UUID is {}' % net_id)
        # elif response[0] == 'NOK':
        #     print("Error on adding network")
        # else:
        #     print("Wrong response for dStore server")
        #self.store.desidered.dput(uri)

    def __catch_signal(self, signal, frame):
        if signal == 2:
            if self.agent is not None:
                self.agent.stop()
                time.sleep(1)
            self.exit(0)

    def __start_node(self, plugin_path, debug):
        signal.signal(signal.SIGINT, self.__catch_signal)
        # TODO should also catch CTRL-BREAK on Windows
        self.agent = FosAgent(debug=debug, plugins_path=plugin_path)
        self.agent.run()
        while True:
            time.sleep(100)

    async def __search_plugin_by_name(self, name, node_uuid):
        uri = 'afos://<sys-id>/{}/plugins'.format(node_uuid)
        all_plugins = await self.store.actual.get(uri)
        # cmd = 'get {0} {1}'.format(self.asid, uri)
        # with self.websocket as ws:
        #     await ws.send(cmd)
        #     response = await ws.recv()
        # all_plugins = response.split(uri)[-1].replace(' ','')
        if all_plugins is None or all_plugins=='':
            print('Cannot get plugin')
            return None
        all_plugins = json.loads(all_plugins).get('plugins')
        search = [x for x in all_plugins if name.upper() in x.get('name').upper()]
        if len(search) == 0:
            return None
        else:
            return search[0]

    async def __get_entity_handler_by_uuid(self, node_uuid, entity_uuid):
        uri = str('afos://<sys-id>/{}/runtime/*/entity/{}'.format(node_uuid, entity_uuid))
        all = await self.store.actual.resolveAll(uri)
        for i in all:
            k = i[0]
            if fnmatch.fnmatch(k, uri):
                # print('MATCH {0}'.format(k))
                # print('Extracting uuid...')
                regex = uri.replace('/', '\/')
                regex = regex.replace('*', '(.*)')
                reobj = re.compile(regex)
                mobj = reobj.match(k)
                uuid = mobj.group(1)
                # print('UUID {0}'.format(uuid))

                return uuid




    async def __get_entity_handler_by_type(self,node_uuid, t):
        handler = None

        handler = await self.__search_plugin_by_name(t, node_uuid)
        if handler is None:
            print('type not yet supported')
        return handler

        # if t == 'kvm':
        #     handler = await self.__search_plugin_by_name('KVM', node_uuid)
        # elif t == 'xen':
        #     handler = await self.__search_plugin_by_name('xen', node_uuid)
        # elif t == 'container':
        #     handler = await self.__search_plugin_by_name('LXD', node_uuid)
        # elif t == 'native':
        #     handler = await self.__search_plugin_by_name('native', node_uuid)
        # elif t == 'ros2':
        #     handler = await self.__search_plugin_by_name('ros2', node_uuid)
        # elif t == 'usvc':
        #     print('microservice not yet')
        # else:
        #     print('type not recognized')
        # return handler

    async  def __send_define_entity(self, node_uuid, manifest):
        manifest.update({'status': 'define'})
        handler = None
        t = manifest.get('type')

        try:
            if t in ['kvm', 'xen']:
                handler = await self.__search_plugin_by_name(t, node_uuid)
                validate(manifest.get('entity_data'), Schemas.vm_schema)
            elif t in ['container', 'lxd']:
                handler = await self.__search_plugin_by_name(t, node_uuid)
                validate(manifest.get('entity_data'), Schemas.container_schema)
            elif t == 'native':
                handler = await self.__search_plugin_by_name('native', node_uuid)
                validate(manifest.get('entity_data'), Schemas.native_schema)
            elif t == 'ros2':
                handler = await self.__search_plugin_by_name('ros2', node_uuid)
                validate(manifest.get('entity_data'), Schemas.ros2_schema)
            elif t == 'usvc':
                print('microservice not yet')
            else:
                print('type not recognized')

            if handler is None:
                print('error on plugin for this type of entity')
                self.exit(-1)
        except ValidationError as ve:
            print('Manifest is not correct')
            print('{}',format(ve.message))
            self.exit(-1)

        entity_uuid = manifest.get('uuid')
        entity_definition = manifest
        json_data = json.dumps(entity_definition).replace(' ','')
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}'.format(node_uuid, handler.get('uuid'), entity_uuid))

        res = await self.store.desired.put(uri, json_data)
        if res:
            while True:
                time.sleep(1)
                uri = str('afos://<sys-id>/{}/runtime/{}/entity/{}'.format(node_uuid, handler.get('uuid'), entity_uuid))
                data = await self.store.actual.get(uri)
                entity_info = None
                if data is not None:
                    entity_info = json.loads(data)
                if entity_info is not None and entity_info.get('status') == 'defined':
                    break
            print("Entity {} defined on node {}".format(entity_uuid, node_uuid))
        else:

            print("Error on define entity")



    async def __send_undefine_entity(self, node_uuid, entity_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}'.format(node_uuid, handler, entity_uuid))

        res = await self.store.desired.remove(uri)
        if res:
            print("Entity {} removed from {}".format(entity_uuid, node_uuid))
        else:
            print("Error on entity remove")

    async def __send_configure_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}#status=configure'.format(node_uuid, handler,
                                                                                          entity_uuid, instance_uuid))
        res = await self.store.desired.dput(uri)
        if res:
            while True:
                time.sleep(1)
                uri = str('afos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid, instance_uuid))
                data = await self.store.actual.get(uri)
                entity_info = None
                if data is not None:
                    entity_info = json.loads(data)
                if entity_info is not None and entity_info.get('status') == 'configured':
                        break
            print("Configured instace {} for entity {} on node {}".format(instance_uuid, entity_uuid, node_uuid))
        else:
            print("Error on configure entity instance")

    async def __send_clean_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid,
                                                                           instance_uuid))
        res = await self.store.desired.remove(uri)
        if res:
            print("Instance {} for entity {} cleaned in node {}".format(instance_uuid, entity_uuid, node_uuid))
        else:
            print("Error on clean entity instance")



    async def __send_run_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}#status=run'.format(node_uuid, handler,
                                                                                      entity_uuid, instance_uuid))

        res = await self.store.desired.dput(uri)
        if res:
            while True:
                time.sleep(1)
                uri = str('afos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid,
                                                                                 instance_uuid))
                data = await self.store.actual.get(uri)
                entity_info = None
                if data is not None:
                    entity_info = json.loads(data)
                if entity_info is not None and entity_info.get('status') == 'run':
                    break
            print("Running instance {} for entity {} on node {}".format(instance_uuid, entity_uuid, node_uuid))
        else:
            print("Error on running entity instance")




    async def __send_stop_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}#status=stop'.format(node_uuid, handler,
                                                                                       entity_uuid, instance_uuid))
        res = await self.store.desired.dput(uri)
        if res:
            while True:
                uri = str('afos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid,
                                                                                 instance_uuid))
                data = await self.store.actual.get(uri)
                entity_info = None
                if data is not None:
                    entity_info = json.loads(data)
                if entity_info is not None and entity_info.get('status') == 'stop':
                    break
            print("Stopped instance {} for entity {} on node {}".format(instance_uuid, entity_uuid, node_uuid))
        else:
            print("Error on stopping entity instance")

    async def __sent_migrate_entity(self, node_uuid, entity_uuid, destination_uuid, instance_uuid):
        handler = await self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('afos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid,
                                                                         instance_uuid))

        entity_info = await self.store.actual.get(uri)
        if entity_info is None:
            print("Error on getting instance info")
            self.exit(-1)

        entity_info = json.loads(entity_info)

        entity_info_src = entity_info.copy()
        entity_info_dst = entity_info.copy()

        entity_info_src.update({"status": "taking_off"})
        entity_info_src.update({"dst": destination_uuid})

        entity_info_dst.update({"status": "landing"})
        entity_info_dst.update({"dst": destination_uuid})

        destination_handler = await self.__get_entity_handler_by_type(destination_uuid, entity_info_dst.get('type'))
        if destination_handler is None:
            print("Error Destination node can't handle this type of entity {0}".format(entity_info_dst.get('type')))
            self.exit(-1)

        uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(destination_uuid, destination_handler.get(
            'uuid'), entity_uuid, instance_uuid))
        res = await self.store.desired.put(uri, json.dumps(entity_info_dst).replace(' ',''))
        if res:
            uri = str('dfos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}'.format(node_uuid, handler, entity_uuid,
                                                                             instance_uuid))
            res_dest = await self.store.desired.dput(uri, json.dumps(entity_info_src).replace(' ',''))
            if res_dest:
                while True:
                    time.sleep(1)
                    uri = str("afos://<sys-id>/{}/runtime/{}/entity/{}/instance/{}".format(destination_uuid,
                                                                                       destination_handler.get('uuid'),
                                                                                       entity_uuid, instance_uuid))
                    data = await self.store.actual.get(uri)
                    entity_info = None
                    if data is not None:
                        entity_info = json.loads(data)
                    if entity_info is not None and entity_info.get("status") == "run":
                        break
                print("Migrated {} (entity {}) from {} to {}".format(instance_uuid,entity_uuid,node_uuid,destination_uuid))
            else:
                print("Error on destination node")
        else:
            print("Error on source node")

    async def __send_pause_entity(self, node_uuid, entity_uuid, instance_uuid):
        pass

    async def __send_resume_entity(self, node_uuid, entity_uuid, instance_uuid):
        pass


    async def __send_add_plugin(self, node_uuid, manifest):
        plugins = {"plugins": [manifest]}
        plugins = json.dumps(plugins).replace(' ','')
        uri = 'dfos://<sys-id>/{}/plugins'.format(node_uuid)
        res = await self.store.desired.dput(uri, plugins)
        if res:
            print("Plugin {} added to {}".format(manifest.get('uuid'),node_uuid))
        else:
            print("Error on adding plugin")

    async def __get_plugins(self,node_uuid):
        uri = str('afos://<sys-id>/{}/plugins'.format(node_uuid))
        plugins = await self.store.actual.get(uri)
        if plugins is not None and plugins != '' :
            plugins = json.loads(plugins).get('plugins')
            print('+-----------------------PLUGINS-------------------------+')
            for p in plugins:
                print('+-------------------------------------------------------+')
                print('| Name: {0} \t| UUID: {1}\t | Type: {2}'
                      .format(p.get('name'), p.get('uuid'), p.get('type')))
            print('+-------------------------------------------------------+')
        else:
            print("No node or plugins found")

    async def __get_nodes(self):
        uri = str('afos://<sys-id>/*/')
        infos = await self.store.actual.resolveAll(uri)
        if infos is not None and infos != '' and len(infos)>0:
            print('+-------------------------------------------------------+')
            for e in infos:
                    node_info = json.loads(e[1])
                    print('| Name: {0} \t| UUID: {1}\t '.format(node_info.get('name'), node_info.get('uuid')))
            print('+-------------------------------------------------------+')
        else:
            print('No node found!!')

    async def __get_networks(self):
        uri = str('afos://<sys-id>/*/network/*/networks/*/')
        nw_list = await self.store.actual.resolveAll(uri)
        if nw_list is not None and len(nw_list)>0:
            for e in nw_list:
                net_info = json.loads(e[1])
                print('+-------------------------------------------------------+')
                print('| UUID : {} \t\t'.format(net_info.get('uuid')))
                print('| Name: {} \t\t'.format(net_info.get('name')))
                print('| Virtual Device: {} \t\t'.format(net_info.get('virtual_device')))
                print('| DHCP: {} \t\t'.format(net_info.get('has_dhcp')))
                print('| IP Range: {} \t\t'.format(net_info.get('ip_range')))
                print('| Gateway: {} \t\t'.format(net_info.get('gateway')))
                print('| VxLAN ID: {} \t\t'.format(net_info.get('vxlan_id')))
                print('| Multicast VxLAN Address: {} \t\t'.format(net_info.get('multicast_address')))
                print('| Node: {} \t\t'.format(e[0].split('/')[-5]))
                print('+-------------------------------------------------------+')
        else:
            print("No network found")


    async def __get_node_details(self, node_uuid, info):
        uri = str('afos://<sys-id>/{}/'.format(node_uuid))
        infos = await self.store.actual.get(uri)
        if infos is not None and infos != '':
            node = json.loads(infos)
            print('+-------------------------------------------------------+')
            print('| Name: {0} \t| UUID: {1}\t '.format(node.get('name'), node.get('uuid')))
            print('+-------------------------------------------------------+')
            if info is True:
                print('+------------------------CPU----------------------------+')
                cpus = node.get('cpu')
                print('| Total CPU {}'.format(len(cpus)))
                for cpu in cpus:
                    print('+-------------------------------------------------------+')
                    print('| ARCH: {}'.format(cpu.get('arch')))
                    print('| Model: {}'.format(cpu.get('model')))
                    print('| Frequency: {}'.format(cpu.get('frequency')))
                print('+-------------------------------------------------------+')
                print('| RAM: {}'.format(node.get('ram').get('size')))
                print('+----------------------NETWORKS-------------------------+')
                nws = node.get("network")
                for nw in nws:
                    print('| ################################################### ')
                    intf_conf = nw.get('inft_configuration')
                    print("| ## Interface: {} ##".format(nw.get('intf_name')))
                    print("| ### MAC: {} ".format(nw.get('intf_mac_address')))
                    print("| ### type: {} ".format(nw.get('type')))
                    print("| ### Default gateway: {} ".format(nw.get('default_gw')))
                    print("| ##### Interface Configuration #####")
                    print("| ###### Speed: {} ".format(intf_conf.get('intf_speed')))
                    print("| ###### IPV4: {} Netmask: {} Gateway: {}".format(intf_conf.get('ipv4_address'),
                                                                         intf_conf.get('ipv4_netmask'),
                                                                         intf_conf.get('ipv4_gateway')))
                    print("| ###### IPV6: {} Netmask: {}".format
                          (intf_conf.get('ipv6_address'), intf_conf.get('ipv6_netmask')))
                print('| ################################################### ')
                accs = node.get('accelerator')
                if accs is not None:
                    print('+----------------------ACCELERATORS-------------------------+')
                    for acc in accs:
                        print('| ################################################### ')
                        print("| ## Name: {} ##".format(acc.get('name')))
                        print("| ## HW Address: {} ##".format(acc.get('hw_address')))
                        print("| ## Supported libraries: {} ##".format(' '.join(acc.get('supported_library'))))
                    print('| ################################################### ')
                ios = node.get('io')
                if ios is not None:
                    print('+----------------------I\O-----------------------------+')
                    for io in ios:
                        print('| ################################################### ')
                        print("| ## Name: {} ##".format(io.get('io_type')))
                        print("| ## Type: {} ##".format(io.get('hw_address')))
                        print("| ## File: {} ##".format(io.get('io_file')))
                    print('| ################################################### ')
                print('+-------------------------------------------------------+')


    async def __get_entities(self):
        uri = str('afos://<sys-id>/*/runtime/*/entity/*')
        entities = await self.store.actual.resolveAll(uri)
        for entity in entities:
            entity_uri = entity[0]
            entity_info = json.loads(entity[1])
            print('| UUID : {} \t\t|'.format(entity_info.get('uuid')))
            print('| Name: {} \t\t|'.format(entity_info.get('name')))
            print('| Type: {} \t\t|'.format(entity_info.get('type')))
            print('| Status: {} \t\t|'.format(entity_info.get('status')))
            print('| Node: {} \t\t|'.format(entity_uri.split('/')[3]))
            print('+-------------------------------------------------------+')

    def start(self, plugins, verbose, daemon):
        if plugins:
            sys.path.append(os.path.abspath(plugins))
            if daemon:
                if os.name == 'posix':
                    print('Forking in backgroud')
                    pid = '/tmp/fos.pid'
                    print('PID file {}'.format(pid))
                    with dmn.DaemonContext(pidfile=pid, umask=0):
                        self.__start_node(plugins, verbose)
                else:
                    print("Cannot daemonize on {} at the moment".format(os.name))
            else:
                self.__start_node(plugins, verbose)
        else:
            print('You should specify plugin path!!')

    def node(self, node_list, node_uuid, plugin_action, action, manifest, plugin_uuid, info):
        if node_list:
            asyncio.get_event_loop().run_until_complete(self.__get_nodes())
            return
        if node_uuid is not None and plugin_action is False:
            asyncio.get_event_loop().run_until_complete(self.__get_node_details(node_uuid, info))
            return
        if node_uuid is not None and plugin_action is True:
            if action == 'add':
                print('Adding plugin from {} to {}'.format(manifest, node_uuid))
                manifest = json.loads(self.__read_file(manifest))
                manifest.update({'status':'add'})
                asyncio.get_event_loop().run_until_complete(self.__send_add_plugin(node_uuid, manifest))
                return
            if action == 'remove':
                print('Removing plugin {} from {} not yet...'.format(plugin_uuid, node_uuid))
                return
            if action == '':
                asyncio.get_event_loop().run_until_complete(self.__get_plugins(node_uuid))
                return




        return


    def network(self,nw_list, node_uuid, add, remove, manifest, net_uuid):
        #print(nw_list, node_uuid, add, remove, manifest, net_uuid)
        if nw_list:
            asyncio.get_event_loop().run_until_complete(self.__get_networks())
            return
        if node_uuid is not None:
            if add and manifest is not None:
                manifest = json.loads(self.__read_file(manifest))
                try:
                    validate(manifest, Schemas.network_schema)
                except ValidationError as ve:
                    print('Manifest is not correct')
                    print('{}'.format(ve.message))
                    return
                print('manifest Ok')
                asyncio.get_event_loop().run_until_complete(self.__send_add_network(node_uuid, manifest))
                return
            if remove and net_uuid is not None:
                asyncio.get_event_loop().run_until_complete(self.__send_remove_network(node_uuid, net_uuid))
                return


    def entity(self, en_list, action, node_uuid, manifest, entity_uuid, instance_uuid, dest_node):
        #print(en_list,action,node_uuid,manifest,entity_uuid,dest_node)
        if en_list:
            asyncio.get_event_loop().run_until_complete(self.__get_entities())
            return
        if node_uuid is None: return
        if action == 'define' and manifest is not None:
            manifest = json.loads(self.__read_file(manifest))
            try:
                validate(manifest, Schemas.entity_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('{}'.format(ve.message))
                return
            print('manifest Ok')
            asyncio.get_event_loop().run_until_complete(self.__send_define_entity(node_uuid, manifest))
            return
        if entity_uuid is None: return
        if action == 'undefine':
            asyncio.get_event_loop().run_until_complete(self.__send_undefine_entity(node_uuid, entity_uuid))
        if action == 'configure' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_configure_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'clean' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_clean_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'run' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_run_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'stop' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_stop_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'pause' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_pause_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'resume' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_resume_entity(node_uuid, entity_uuid, instance_uuid))
        if action == 'migrate' and dest_node is not None and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__sent_migrate_entity(node_uuid, entity_uuid, dest_node, instance_uuid))



    def manifest(self, type, manifest):
        manifest = json.loads(self.__read_file(manifest))
        if type == 'entity':
            t = manifest.get('type')
            try:
                if t == 'vm':
                    validate(manifest.get('entity_data'), Schemas.vm_schema)
                elif t == 'container':
                    validate(manifest.get('entity_data'), Schemas.container_schema)
                elif t == 'native':
                    validate(manifest.get('entity_data'), Schemas.native_schema)
                elif t == 'ros2':
                    validate(manifest.get('entity_data'), Schemas.ros2_schema)
                elif t == 'usvc':
                    print('microservice not yet')
                else:
                    print('type not recognized')
            except ValidationError as ve:
                print('Manifest is not correct')
                print('{}'.format(ve.message))
                self.exit(-1)
        if type == 'network':
            try:
                validate(manifest, Schemas.network_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('{}'.format(ve.message))
                self.exit(-1)
        if type == 'application':
            try:
                validate(manifest, Schemas.app_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('{}'.format(ve.message))
                self.exit(-1)

        print('Manifest seems ok!')
        return



    def main(self):
        parser = argparse.ArgumentParser(description='Fog05 | The Fog-Computing IaaS')
        subparsers = parser.add_subparsers(dest='cmd')

        ##START CMD

        parser_start = subparsers.add_parser('start')
        parser_start.add_argument('-p', '--plugins', required=True, type=str, default=False, help='plugin path')
        parser_start.add_argument('-v', '--verbose', action='store_true', default=False, help='Verbose output')
        parser_start.add_argument('-d', '--daemon', action='store_true', default=False, help='Run as a daemon')


        ## NODE CMD
        parser_node = subparsers.add_parser('node')

        node_grp = parser_node.add_mutually_exclusive_group(required=True)

        node_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all nodes')
        node_grp.add_argument('-u', '--uuid',  type=str, default=None, help='Node uuid')

        parser_node.add_argument('-p','-plugin', action='store_true', default=False, help='enable action on plugin',
                                 dest='plugin')
        parser_node.add_argument('-i', '--info', action='store_true', default=False, help='detailed info', dest='info')

        node_plugin_grp = parser_node.add_mutually_exclusive_group(required=False)
        node_plugin_grp.add_argument('-a', '--add', action='store_true', default=False, help='add plugin')
        node_plugin_grp.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin')

        #parser_node.add_argument('-a', '--add', nargs='?', type=bool, default=False, help='add plugin', dest='action')
        #parser_node.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin',
        #                         dest='action')

        parser_node.add_argument('-m', '--manifest', type=str, default=None, help='plugin manifest')
        parser_node.add_argument('-pu', '--puuid', type=str, default=None, help='plugin uuid')



        ## NETWORK CMD
        parser_network = subparsers.add_parser('network')
        network_grp = parser_network.add_mutually_exclusive_group(required=True)

        network_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        network_grp.add_argument('-a','--add', action='store_true', help='add network')
        network_grp.add_argument('-r','--remove', action='store_true', help='remove network')

        parser_network.add_argument('-m', '--manifest', type=str, default=None, help='network manifest')
        parser_network.add_argument('-nu', '--nuuid', type=str, default=None, help='network uuid')
        parser_network.add_argument('-u', '--uuid', type=str, default=None, help='node uuid')

        ## ENTITY CMD
        parser_entity = subparsers.add_parser('entity')
        entity_grp = parser_entity.add_mutually_exclusive_group(required=True)

        entity_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        entity_grp.add_argument('-a', '--add', action='store_true', help='add entity')
        entity_grp.add_argument('-r', '--remove', action='store_true', help='remove entity')
        entity_grp.add_argument('--define', action='store_true', help='define entity')
        entity_grp.add_argument('--undefine', action='store_true', help='remove entity')
        entity_grp.add_argument('--configure', action='store_true', help='configure entity')
        entity_grp.add_argument('--clean', action='store_true', help='clean entity')
        entity_grp.add_argument('--run', action='store_true', help='run entity')
        entity_grp.add_argument('--stop', action='store_true', help='stop entity')
        entity_grp.add_argument('--pause', action='store_true', help='pause entity')
        entity_grp.add_argument('--resume', action='store_true', help='resume entity')
        entity_grp.add_argument('--migrate', action='store_true', help='migrate entity')

        parser_entity.add_argument('-m', '--manifest', type=str, default=None, help='entity manifest')
        parser_entity.add_argument('-eu', '--euuid', type=str, default=None, help='entity uuid')
        parser_entity.add_argument('-iu', '--iuuid', type=str, default=None, help='instance uuid')
        parser_entity.add_argument('-u', '--uuid', type=str, default=None, help='node uuid')
        parser_entity.add_argument('-du', '--duuid', type=str, default=None, help='destination node uuid')

        ## MANIFEST CMD
        parser_manifest = subparsers.add_parser('manifest')
        manifest_grp = parser_manifest.add_mutually_exclusive_group(required=True)
        manifest_grp.add_argument('-n', '--network', action='store_true', help='network manifest')
        manifest_grp.add_argument('-e', '--entity', action='store_true', help='entity manifest')
        manifest_grp.add_argument('-a', '--application', action='store_true', help='application manifest')
        parser_manifest.add_argument('manifest', type=str, default=None, help='manifest path')


        kwargs = vars(parser.parse_args())
        #print(kwargs)

        if kwargs['cmd'] == 'start':
            self.start(kwargs['plugins'], kwargs['verbose'], kwargs['daemon'])

        elif kwargs['cmd'] == 'manifest':
            type = ''
            if kwargs['network'] is True: type = 'network'
            if kwargs['entity'] is True: type = 'entity'
            if kwargs['application'] is True: type = 'application'
            self.manifest(type, kwargs['manifest'])

        else:
            self.__initialize()
            if kwargs['cmd'] == 'node':
                action = ''
                if kwargs['add'] is True: action = 'add'
                elif kwargs['remove'] is True: action = 'remove'
                self.node(kwargs['list'], kwargs['uuid'], kwargs['plugin'], action, kwargs['manifest'],
                          kwargs['puuid'],kwargs['info'])
                self.exit(0)
            elif kwargs['cmd'] == 'network':
                self.network(kwargs['list'],kwargs['uuid'], kwargs['add'], kwargs['remove'], kwargs['manifest'],
                             kwargs['nuuid'])
                self.exit(0)
            elif kwargs['cmd'] == 'entity':

                action = ''
                if kwargs['add'] is True: action = 'add'
                if kwargs['remove'] is True: action = 'remove'
                if kwargs['define'] is True: action = 'define'
                if kwargs['undefine'] is True: action = 'undefine'
                if kwargs['configure'] is True: action = 'configure'
                if kwargs['clean'] is True: action = 'clean'
                if kwargs['run'] is True: action = 'run'
                if kwargs['stop'] is True: action = 'stop'
                if kwargs['pause'] is True: action = 'pause'
                if kwargs['resume'] is True: action = 'resume'
                if kwargs['migrate'] is True: action = 'migrate'

                self.entity(kwargs['list'], action, kwargs['uuid'], kwargs['manifest'], kwargs['euuid'],
                            kwargs['iuuid'],kwargs['duuid'])

                self.exit(0)
            else:
                print('Error check your command line!!')
                exit(-1)


if __name__ == '__main__':
        c = FOSCli('localhost')
        c.main()