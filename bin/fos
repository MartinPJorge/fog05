#!/usr/bin/env python3

import sys
import re
from jsonschema import validate, ValidationError
from fog05.DStore import *
from fog05 import Schemas
import signal
from fog05.fosagent import FosAgent
import time
import uuid
import argparse

import os
## cli using webserver
import asyncio
import websockets


if os.name == 'posix':
    import daemon as dmn


##
## TODO: sostitute all string with variables in store interaction
##


class WSStore(object):
    def __init__(self, sid, root, home, host):
        self.sid = sid
        self.root = root
        self.home = home
        self.host = host
        self.websocket = websockets.connect('ws://{}:9669'.format(host))

    async def create(self):
        cmd = 'create {} {} {} 1024'.format(self.sid, self.root, self.home)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def put(self, uri, val):
        cmd = 'put {} {} {}'.format(self.sid, uri, val)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def dput(self, uri, value=None):
        if value is None:
            cmd = 'dput {} {}'.format(self.sid, uri)
        else:
            cmd = 'dput {} {} {}'.format(self.sid, uri, value)

        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False

    async def get(self, uri):
        cmd = 'get {} {}'.format(self.sid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            return infos
        else:
            return None

    async def getAll(self, uri):
        cmd = 'aget {0} {1}'.format(self.sid, uri)
        values=[]
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            nodes_list = infos.split('|')
            for e in nodes_list:
                i = e.split('@')
                v = []
                v.append(i[0])
                v.append(''.join(i[1:]))
                values.append(tuple(v))

        return tuple(values)


    async def remove(self, uri):
        cmd = 'remove {} {}'.format(self.sid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        response = response.split(' ')
        if response[0] == 'OK':
            return True
        elif response[0] == 'NOK':
            return False
        else:
            print("Wrong response from the server {}".format(''.join(response)))
            return False


class FOSStore(object):
    def __init__(self, aroot, droot, home, host):
        self.aroot = aroot #'dfos://<sys-id>'
        self.ahome = str('%s/%s' % (aroot, home)) #str('dfos://<sys-id>/%s' % self.uuid)

        self.droot = droot  # 'dfos://<sys-id>'
        self.dhome = str('%s/%s' % (droot, home))  # str('dfos://<sys-id>/%s' % self.uuid)

        self.actual = WSStore('a{}'.format(home), self.aroot, self.ahome, host)
        self.desidered = WSStore('d{}'.format(home), self.droot, self.dhome, host)

    def close(self):
        pass
        #self.actual.close()
        #self.desidered.close()


class FOSCli(object):

    def __init__(self,host):
        #self.agent = None
        self.store = None
        self.aroot = 'afos://<sys-id>'
        self.droot = 'dfos://<sys-id>'
        self.uuid = 'localhost'
        self.host = host



        # TODO should be removed after wrapping implemented
        self.websocket = None
        self.asid = 'alocalhost'
        self.dsid = 'dlocalhost'



    def __initialize(self):
        self.websocket = websockets.connect('ws://localhost:9669')

        self.store = FOSStore(self.aroot, self.droot, self.uuid,self.host)

        #if len(self.store.actual.discovered_stores) == 0:
        #    time.sleep(3)
        #if len(self.store.desidered.discovered_stores) == 0:
        #    time.sleep(3)

    def __read_file(self, file_path):
        with open(file_path, 'r') as f:
            data = f.read()
        return data

    def exit(self, exit_code):
        if self.store is not None:
            self.store.close()
        exit(exit_code)

    # TODO wrap command to webservice
    #async def __send_to_ws(self, id, uri, values=None):



    async def __get_all_node_plugin(self,node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        cmd = 'get {} {}'.format(self.asid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
            response = response.split(uri)[-1].replace(' ', '')
        if response is not None and response !='':
            return json.loads(response).get('plugins')
        else:
            return None

    async def __send_add_network(self, node_uuid, manifest):

        manifest.update({'status':'add'})
        all_plugins = await self.__get_all_node_plugin(node_uuid)
        if all_plugins is None:
            print('Error on receive plugin from node')
            return
        nws = [x for x in all_plugins if x.get('type') == 'network']
        if len(nws) == 0:
            print('No network plugin loaded on node, aborting')
            return
        brctl = nws[0]  # will use the first plugin

        uri = str('dfos://<sys-id>/%s/plugins' % node_uuid)
        #print(uri)
        json_data = json.dumps(manifest)
        uri = str('dfos://<sys-id>/%s/network/%s/networks/%s' %
                  (node_uuid, brctl.get('uuid'), manifest.get('uuid')))

        cmd = 'put {0} {1} {2}'.format(self.sid, uri, json_data)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        print('{0} NETWORK {1} ADD'.format(response,manifest.get('uuid')))

        response = response.split(' ')
        if response[0] == 'OK':
            print('Network UUID is %s' % manifest.get('uuid'))
        elif response[0] == 'NOK':
            print("Error on adding network")
        else:
            print("Wrong response for dStore server")
        #r = self.store.desidered.put(uri, json_data)
        #if r is None:
        #    print('Resolved failed')
        #elif r:
        #    print('network added')

    async def __send_remove_network(self, node_uuid, net_id):

        all_plugins = await self.__get_all_node_plugin(node_uuid)
        if all_plugins is None:
            print('Error on receive plugin from node')
            return
        nws = [x for x in all_plugins if x.get('type') == 'network']
        #print('locating brctl plugin')
        search = [x for x in nws if 'brctl' in x.get('name')]
        #print(search)
        if len(search) == 0:
            print('Plugin was not loaded')
            exit(0)
        else:
            brctl = search[0]

        uri = str('dfos://<sys-id>/%s/network/%s/networks/%s' % (node_uuid, brctl.get('uuid'), net_id))

        cmd = 'remove {0} {1}'.format(self.sid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        print('{0} NETWORK {1} REMOVE'.format(response, net_id))

        response = response.split(' ')
        if response[0] == 'OK':
            print('Network UUID is %s' % net_id)
        elif response[0] == 'NOK':
            print("Error on adding network")
        else:
            print("Wrong response for dStore server")


        #self.store.desidered.dput(uri)

    def __catch_signal(self, signal, frame):
        if signal == 2:
            if self.agent is not None:
                self.agent.stop()
                time.sleep(1)
            self.exit(0)

    def __start_node(self, plugin_path, debug):
        signal.signal(signal.SIGINT, self.__catch_signal)
        # TODO should also catch CTRL-BREAK on Windows
        self.agent = FosAgent(debug=debug, plugins_path=plugin_path)
        self.agent.run()
        while True:
            time.sleep(100)

    async def __search_plugin_by_name(self, name, node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        cmd = 'get {0} {1}'.format(self.asid, uri)
        with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        all_plugins = response.split(uri)[-1].replace(' ','')
        if all_plugins is None or all_plugins=='':
            print('Cannot get plugin')
            return None
        #all_plugins = all_plugins
        all_plugins = json.loads(all_plugins).get('plugins')
        search = [x for x in all_plugins if name in x.get('name')]
        if len(search) == 0:
            return None
        else:
            return search[0]

    async def __get_entity_handler_by_uuid(self, node_uuid, entity_uuid):
        uri = str('afos://<sys-id>/%s/runtime/*/entity/%s' % (node_uuid, entity_uuid))
        cmd = 'aget {0} {1}'.format(self.asid, uri)
        with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            #print('+-------------------------------------------------------+')
            infos_list = infos.split('|')
            for e in infos_list:
                k = e[1]
                if fnmatch.fnmatch(k, uri):
                    # print('MATCH {0}'.format(k))
                    # print('Extracting uuid...')
                    regex = uri.replace('/', '\/')
                    regex = regex.replace('*', '(.*)')
                    reobj = re.compile(regex)
                    mobj = reobj.match(k)
                    uuid = mobj.group(1)
                    # print('UUID {0}'.format(uuid))
                    return uuid




    def __get_entity_handler_by_type(self,node_uuid, t):
        handler = None
        if t == 'vm':
            handler = self.__search_plugin_by_name('KVM', node_uuid)
        elif t == 'container':
            handler = self.__search_plugin_by_name('LXD', node_uuid)
        elif t == 'native':
            handler = self.__search_plugin_by_name('native', node_uuid)
        elif t == 'ros2':
            handler = self.__search_plugin_by_name('ros2', node_uuid)
        elif t == 'usvc':
            print('microservice not yet')
        else:
            print('type not recognized')
        return handler

    async  def __send_define_entity(self, node_uuid, manifest):
        manifest.update({'status': 'define'})
        handler = None
        t = manifest.get('type')

        try:
            if t == 'vm':
                handler = self.__search_plugin_by_name('KVM', node_uuid)
                validate(manifest.get('entity_data'), Schemas.vm_schema)
            elif t == 'container':
                handler = self.__search_plugin_by_name('LXD', node_uuid)
                validate(manifest.get('entity_data'), Schemas.container_schema)
            elif t == 'native':
                handler = self.__search_plugin_by_name('native', node_uuid)
                validate(manifest.get('entity_data'), Schemas.native_schema)
            elif t == 'ros2':
                handler = self.__search_plugin_by_name('ros2', node_uuid)
                validate(manifest.get('entity_data'), Schemas.ros2_schema)
            elif t == 'usvc':
                print('microservice not yet')
            else:
                print('type not recognized')

            if handler is None:
                print('error on plugin for this type of entity')
                self.exit(-1)
        except ValidationError as ve:
            print('Manifest is not correct')
            print('%s' % ve.message)
            self.exit(-1)

        entity_uuid = manifest.get('uuid')
        entity_definition = manifest
        json_data = json.dumps(entity_definition)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s' % (node_uuid, handler.get('uuid'), entity_uuid))

        cmd = 'put {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        print('{0} ENTITY {1} ADD'.format(response,manifest.get('uuid')))

        response = response.split(' ')
        if response[0] == 'OK':
            print('Entity UUID is %s' % manifest.get('uuid'))
        elif response[0] == 'NOK':
            print("Error")
        else:
            print("Wrong response for dStore server")

        #self.store.desidered.put(uri, json_data)


        while True:
            time.sleep(1)
            uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s' % (node_uuid, handler.get('uuid'), entity_uuid))
            cmd = 'get {0} {1}'.format(self.asid, uri)
            async with self.websocket as ws:
                await ws.send(cmd)
                response = await ws.recv()
            infos = response.split(uri)[-1].replace(' ', '')
            if infos[-1] is not None and infos!='':
                entity_info = json.loads(infos[-1])
                if entity_info is not None and entity_info.get('status') == 'defined':
                    break

    async def __send_undefine_entity(self, node_uuid, entity_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s' % (node_uuid, handler, entity_uuid))

        cmd = 'remove {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return

        #self.store.desidered.remove(uri)
        #time.sleep(2)

    async def __send_configure_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s#status=configure' % (node_uuid, handler,
                                                                                        entity_uuid, instance_uuid))
        #self.store.desidered.dput(uri)

        cmd = 'dput {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return

        while True:
            time.sleep(1)
            uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid,instance_uuid))
            cmd = 'get {0} {1}'.format(self.dsid, uri)
            async with self.websocket as ws:
                await ws.send(cmd)
                response = await  ws.recv()
            infos = response.split(uri)[-1].replace(' ', '')
            if infos[-1] is not None and infos != '':
                entity_info = json.loads(infos[-1])
                if entity_info is not None and entity_info.get('status') == 'configured':
                    break

            #uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid,
            # instance_uuid))
            #data = self.store.actual.get(uri)
            #entity_info = None
            #if data is not None:
            #    entity_info = entity_info = json.loads(data)
            #if entity_info is not None and entity_info.get('status') == 'configured':
            #    break

    async def __send_clean_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        # uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s#status=clean' % (node_uuid, handler,
        #                                                                                 entity_uuid, instance_uuid))
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid,
                                                                           instance_uuid))

        cmd = 'remove {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return

        #self.store.desidered.remove(uri)
        #self.store.desidered.dput(uri)
        # while True:
        #     time.sleep(1)
        #     uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid, instance_uuid))
        #     data = self.store.actual.get(uri)
        #     entity_info = None
        #     if data is not None:
        #         entity_info = entity_info = json.loads(data)
        #     if entity_info is not None and entity_info.get('status') == 'cleaned':
        #         break

    async def __send_run_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s#status=run' % (node_uuid, handler,
                                                                                      entity_uuid, instance_uuid))

        cmd = 'dput {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return

        #self.store.desidered.dput(uri)
        while True:
            time.sleep(1)
            uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid, instance_uuid))
            cmd = 'get {0} {1}'.format(self.dsid, uri)
            async with self.websocket as ws:
                await ws.send(cmd)
                response = await  ws.recv()
            infos = response.split(uri)[-1].replace(' ', '')
            if infos[-1] is not None and infos != '':
                entity_info = json.loads(infos[-1])
                if entity_info is not None and entity_info.get('status') == 'run':
                    break

            # data = self.store.actual.get(uri)
            # entity_info = None
            # if data is not None:
            #     entity_info = entity_info = json.loads(data)


    async def __send_stop_entity(self, node_uuid, entity_uuid, instance_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s#status=stop' % (node_uuid, handler,
                                                                                       entity_uuid, instance_uuid))
        cmd = 'dput {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return


        #self.store.desidered.dput(uri)
        while True:
            uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid, instance_uuid))
            # data = self.store.actual.get(uri)
            # entity_info = None
            # if data is not None:
            #     entity_info = entity_info = json.loads(data)
            time.sleep(1)
            cmd = 'get {0} {1}'.format(self.dsid, uri)
            async with self.websocket as ws:
                await ws.send(cmd)
                response = await  ws.recv()
            infos = response.split(uri)[-1].replace(' ', '')
            if infos[-1] is not None and infos != '':
                entity_info = json.loads(infos[-1])
                if entity_info is not None and entity_info.get('status') == 'stop':
                    break

    async def __sent_migrate_entity(self, node_uuid, entity_uuid, destination_uuid, instance_uuid):
        handler = self.__get_entity_handler_by_uuid(node_uuid, entity_uuid)
        uri = str('afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid, instance_uuid))
        entity_info = json.loads(self.store.actual.get(uri))

        entity_info_src = entity_info.copy()
        entity_info_dst = entity_info.copy()

        entity_info_src.update({"status": "taking_off"})
        entity_info_src.update({"dst": destination_uuid})

        entity_info_dst.update({"status": "landing"})
        entity_info_dst.update({"dst": destination_uuid})

        destination_handler = self.__get_entity_handler_by_type(destination_uuid, entity_info_dst.get('type'))
        if destination_handler is None:
            print("Error Destination node can't handle this type of entity {0}".format(entity_info_dst.get('type')))
            self.exit(-1)

        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (destination_uuid, destination_handler.get(
            'uuid'), entity_uuid, instance_uuid))
        #self.store.desidered.put(uri, json.dumps(entity_info_dst))

        cmd = 'put {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return



        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s' % (node_uuid, handler, entity_uuid, instance_uuid))

        cmd = 'dput {} {}'.format(self.dsid, uri)

        async with self.websocket as ws:
            await ws.send(cmd)
        response = await ws.recv()

        response = response.split(' ')
        if response[0] == 'OK':
            pass
        elif response[0] == 'NOK':
            print("Error")
            return
        else:
            print("Wrong response for dStore server")
            return


        #self.store.desidered.dput(uri, json.dumps(entity_info_src))

        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s/instance/%s" % (destination_uuid,
                                                                               destination_handler.get('uuid'),
                                                                               entity_uuid, instance_uuid))
            # data = self.store.actual.get(uri)
            # entity_info = None
            # if data is not None:
            #     entity_info = entity_info = json.loads(data)
            cmd = 'get {0} {1}'.format(self.dsid, uri)
            async with self.websocket as ws:
                await ws.send(cmd)
                response = await  ws.recv()
            infos = response.split(uri)[-1].replace(' ', '')
            if infos[-1] is not None and infos != '':
                entity_info = json.loads(infos[-1])
                if entity_info is not None and entity_info.get("status") == "run":
                    break

    def __send_pause_entity(self, node_uuid, entity_uuid, instance_uuid):
        pass

    def __send_resume_entity(self, node_uuid, entity_uuid, instance_uuid):
        pass


    async def __send_add_plugin(self, node_uuid, manifest):
        plugins = {"plugins": [manifest]}

        plugins = json.dumps(plugins)
        plugins = plugins.replace(" ", "")
        # uri = str('afos://<sys-id>/%s/plugins' % uuid)
        # plugins = json.loads(self.store.actual.get(uri))
        # plugins.get('plugins').append(manifest)
        # print(plugins)
        uri = str('dfos://<sys-id>/%s/plugins' % node_uuid)
        cmd = 'dput {0} {1} {2}'.format(self.dsid, uri, plugins)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
            print('{0} PLUGIN {1} ADD'.format(response, manifest.get('uuid')))

        # self.store.desidered.dput(uri, json.dumps(plugins))

    async def __get_plugins(self,node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        cmd = 'get {0} {1}'.format(self.asid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        plugins = response.split(uri)[-1].replace(' ','')
        if plugins is not None and plugins != '' :
            plugins = json.loads(plugins).get('plugins')
            print('+-----------------------PLUGINS-------------------------+')
            for p in plugins:
                print('+-------------------------------------------------------+')
                print('| Name: {0} \t| UUID: {1}\t | Type: {2}'
                      .format(p.get('name'), p.get('uuid'), p.get('type')))
            print('+-------------------------------------------------------+')
        else:
            print("No node or plugins found")

    async def __get_nodes(self):
        uri = str('afos://<sys-id>/*/')
        cmd = 'aget {0} {1}'.format(self.asid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ','')
        if infos is not None and infos != '':
            print('+-------------------------------------------------------+')
            nodes_list = infos.split('|')
            for e in nodes_list:
                e = e.split('@')
                i = ''.join(e[1:])
                node_info = json.loads(i)

                print('| Name: {0} \t| UUID: {1}\t '.format(node_info.get('name'), node_info.get('uuid')))
            print('+-------------------------------------------------------+')
        else:
            print('No node found!!')

    async def __get_networks(self):
        uri = str('afos://<sys-id>/*/network/*/networks/*/')
        cmd = 'aget {0} {1}'.format(self.asid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ','')
        if infos is not None and infos != '':
            print('+-------------------------------------------------------+')
            nw_list = infos.split('|')
            for e in nw_list:
                    net_info = json.loads(e[1])
                    print('| UUID : %s \t\t' % net_info.get('uuid'))
                    print('| Name: %s \t\t' % net_info.get('name'))
                    print('| Virtual Device: %s \t\t' % net_info.get('virtual_device'))
                    print('| DHCP: %s \t\t' % net_info.get('has_dhcp'))
                    print('| IP Range: %s \t\t' % net_info.get('ip_range'))
                    print('| Gateway: %s \t\t' % net_info.get('gateway'))
                    print('| VxLAN ID: %s \t\t' % net_info.get('vxlan_id'))
                    print('| Multicast VxLAN Address: %s \t\t' % net_info.get('multicast_address'))
                    print('| Node: %s \t\t' % e[0].split('/')[-5])
            print('+-------------------------------------------------------+')
        else:
            print('No node found!!')

    async def __get_node_details(self, node_uuid, info):
        uri = str('afos://<sys-id>/{}/'.format(node_uuid))
        cmd = 'get {0} {1}'.format(self.asid, uri)
        async with self.websocket as ws:
            await ws.send(cmd)
            response = await ws.recv()
        infos = response.split(uri)[-1].replace(' ', '')
        if infos is not None and infos != '':
            node = json.loads(infos)
            print('+-------------------------------------------------------+')
            print('| Name: {0} \t| UUID: {1}\t '.format(node.get('name'), node.get('uuid')))
            print('+-------------------------------------------------------+')
            if info is True:
                print('+------------------------CPU----------------------------+')
                cpus = node.get('cpu')
                print('| Total CPU %d' % len(cpus))
                for cpu in cpus:
                    print('+-------------------------------------------------------+')
                    print('| ARCH: %s' % cpu.get('arch'))
                    print('| Model: %s' % cpu.get('model'))
                    print('| Frequency: %s' % cpu.get('frequency'))
                print('+-------------------------------------------------------+')
                print('| RAM: %d' % node.get('ram').get('size'))
                print('+----------------------NETWORKS-------------------------+')
                nws = node.get("network")
                for nw in nws:
                    print('| ################################################### ')
                    intf_conf = nw.get('inft_configuration')
                    print("| ## Interface: %s ##" % nw.get('intf_name'))
                    print("| ### MAC: %s " % nw.get('intf_mac_address'))
                    print("| ### type: %s " % nw.get('type'))
                    print("| ### Default gateway: %s " % nw.get('default_gw'))
                    print("| ##### Interface Configuration #####")
                    print("| ###### Speed: %s " % intf_conf.get('intf_speed'))
                    print("| ###### IPV4: %s Netmask: %s Gateway: %s" % (intf_conf.get('ipv4_address'),
                                                                         intf_conf.get('ipv4_netmask'),
                                                                         intf_conf.get('ipv4_gateway')))
                    print("| ###### IPV6: %s Netmask: %s" %
                          (intf_conf.get('ipv6_address'), intf_conf.get('ipv6_netmask')))
                print('| ################################################### ')
                accs = node.get('accelerator')
                if accs is not None:
                    print('+----------------------ACCELERATORS-------------------------+')
                    for acc in accs:
                        print('| ################################################### ')
                        print("| ## Name: %s ##" % acc.get('name'))
                        print("| ## HW Address: %s ##" % acc.get('hw_address'))
                        print("| ## Supported libraries: %s ##"
                              % ' '.join(acc.get('supported_library')))
                    print('| ################################################### ')
                ios = node.get('io')
                if ios is not None:
                    print('+----------------------I\O-----------------------------+')
                    for io in ios:
                        print('| ################################################### ')
                        print("| ## Name: %s ##" % io.get('io_type'))
                        print("| ## Type: %s ##" % io.get('hw_address'))
                        print("| ## File: %s ##" % io.get('io_file'))
                    print('| ################################################### ')
                print('+-------------------------------------------------------+')

    def start(self, plugins, verbose, daemon):
        if plugins:
            sys.path.append(os.path.abspath(plugins))
            if daemon:
                if os.name == 'posix':
                    print('Forking in backgroud')
                    pid = '/tmp/fos.pid'
                    print('PID file %s' % pid)
                    with dmn.DaemonContext(pidfile=pid, umask=0):
                        self.__start_node(plugins, verbose)
                else:
                    print("Cannot daemonize on {0} at the moment".format(os.name))
            else:
                self.__start_node(plugins, verbose)
        else:
            print('You should specify plugin path!!')

    def node(self, node_list, node_uuid, plugin_action, action, manifest, plugin_uuid, info):
        if node_list:
            asyncio.get_event_loop().run_until_complete(self.__get_nodes())
            return
        if node_uuid is not None and plugin_action is False:
            asyncio.get_event_loop().run_until_complete(self.__get_node_details(node_uuid, info))
            return
        if node_uuid is not None and plugin_action is True:
            if action == 'add':
                print('Adding plugin from %s to %s' % (manifest, node_uuid))
                manifest = json.loads(self.__read_file(manifest))
                manifest.update({'status':'add'})
                asyncio.get_event_loop().run_until_complete(self.__send_add_plugin(node_uuid, manifest))
                return
            if action == 'remove':
                print('Removing plugin %s from %s not yet...' % (plugin_uuid, node_uuid))
                return
            if action == '':
                asyncio.get_event_loop().run_until_complete(self.__get_plugins(node_uuid))
                return




        return


    def network(self,nw_list, node_uuid, add, remove, manifest, net_uuid):
        #print(nw_list, node_uuid, add, remove, manifest, net_uuid)
        if nw_list:
            asyncio.get_event_loop().run_until_complete(self.__get_networks())
            return
        if node_uuid is not None:
            if add and manifest is not None:
                manifest = json.loads(self.__read_file(manifest))
                try:
                    validate(manifest, Schemas.network_schema)
                except ValidationError as ve:
                    print('Manifest is not correct')
                    print('%s' % ve.message)
                    return
                print('manifest Ok')
                asyncio.get_event_loop().run_until_complete(self.__send_add_network(node_uuid, manifest))
                return
            if remove and net_uuid is not None:
                asyncio.get_event_loop().run_until_complete(self.__send_remove_network(node_uuid, net_uuid))
                return


    def entity(self, en_list, action, node_uuid, manifest, entity_uuid, instance_uuid, dest_node):
        #print(en_list,action,node_uuid,manifest,entity_uuid,dest_node)
        if en_list:
            uri = str('afos://<sys-id>/*/runtime/*/entity/*')
            entities = self.store.actual.resolveAll(uri)
            for entity in entities:
                entity_uri = entity[0]
                entity_info = json.loads(entity[1])
                print('| UUID : %s \t\t|' % entity_info.get('uuid'))
                print('| Name: %s \t\t|' % entity_info.get('name'))
                print('| Type: %s \t\t|' % entity_info.get('type'))
                print('| Status: %s \t\t|' % entity_info.get('status'))
                print('| Node: %s \t\t|' % entity_uri.split('/')[3])

            return
        if node_uuid is None: return
        if action == 'define' and manifest is not None:
            manifest = json.loads(self.__read_file(manifest))
            try:
                validate(manifest, Schemas.entity_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('%s' % ve.message)
                return
            print('manifest Ok')
            asyncio.get_event_loop().run_until_complete(self.__send_define_entity(node_uuid, manifest))
            #print('Entity %s defined' % manifest.get('uuid'))
            return
        if entity_uuid is None: return
        if action == 'undefine':
            asyncio.get_event_loop().run_until_complete(self.__send_undefine_entity(node_uuid, entity_uuid))
            #print('Entity %s undefined' % entity_uuid)
        if action == 'configure' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_configure_entity(node_uuid, entity_uuid,
                                                                                     instance_uuid))
            #print('Entity %s configured' % entity_uuid)
        if action == 'clean' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_clean_entity(node_uuid, entity_uuid, instance_uuid))
            #print('Entity %s cleaned' % entity_uuid)
        if action == 'run' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_run_entity(node_uuid, entity_uuid, instance_uuid))
            #print('Entity %s started' % entity_uuid)
        if action == 'stop' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_stop_entity(node_uuid, entity_uuid, instance_uuid))
            #print('Entity %s stopped' % entity_uuid)
        if action == 'pause' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_pause_entity(node_uuid, entity_uuid, instance_uuid))
            #print('Pause sended')
        if action == 'resume' and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__send_resume_entity(node_uuid, entity_uuid,
                                                                                  instance_uuid))
            #print('Resume sended')
        if action == 'migrate' and dest_node is not None and instance_uuid is not None:
            asyncio.get_event_loop().run_until_complete(self.__sent_migrate_entity(node_uuid, entity_uuid, dest_node,
                                                                                   instance_uuid))
            #print('Migration sended')


    def manifest(self, type, manifest):
        manifest = json.loads(self.__read_file(manifest))
        if type == 'entity':
            t = manifest.get('type')
            try:
                if t == 'vm':
                    validate(manifest.get('entity_data'), Schemas.vm_schema)
                elif t == 'container':
                    validate(manifest.get('entity_data'), Schemas.container_schema)
                elif t == 'native':
                    validate(manifest.get('entity_data'), Schemas.native_schema)
                elif t == 'ros2':
                    validate(manifest.get('entity_data'), Schemas.ros2_schema)
                elif t == 'usvc':
                    print('microservice not yet')
                else:
                    print('type not recognized')
            except ValidationError as ve:
                print('Manifest is not correct')
                print('%s' % ve.message)
                self.exit(-1)
        if type == 'network':
            try:
                validate(manifest, Schemas.network_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('%s' % ve.message)
                self.exit(-1)
        if type == 'application':
            try:
                validate(manifest, Schemas.app_schema)
            except ValidationError as ve:
                print('Manifest is not correct')
                print('%s' % ve.message)
                self.exit(-1)

        print('Manifest seems ok!')
        return



    def main(self):
        parser = argparse.ArgumentParser(description='Fog05 | The Fog-Computing IaaS')
        subparsers = parser.add_subparsers(dest='cmd')

        ##START CMD

        parser_start = subparsers.add_parser('start')
        parser_start.add_argument('-p', '--plugins', required=True, type=str, default=False, help='plugin path')
        parser_start.add_argument('-v', '--verbose', action='store_true', default=False, help='Verbose output')
        parser_start.add_argument('-d', '--daemon', action='store_true', default=False, help='Run as a daemon')


        ## NODE CMD
        parser_node = subparsers.add_parser('node')

        node_grp = parser_node.add_mutually_exclusive_group(required=True)

        node_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all nodes')
        node_grp.add_argument('-u', '--uuid',  type=str, default=None, help='Node uuid')

        parser_node.add_argument('-p','-plugin', action='store_true', default=False, help='enable action on plugin',
                                 dest='plugin')
        parser_node.add_argument('-i', '--info', action='store_true', default=False, help='detailed info', dest='info')

        node_plugin_grp = parser_node.add_mutually_exclusive_group(required=False)
        node_plugin_grp.add_argument('-a', '--add', action='store_true', default=False, help='add plugin')
        node_plugin_grp.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin')

        #parser_node.add_argument('-a', '--add', nargs='?', type=bool, default=False, help='add plugin', dest='action')
        #parser_node.add_argument('-r', '--remove', nargs='?', type=bool, default=False, help='remove plugin',
        #                         dest='action')

        parser_node.add_argument('-m', '--manifest', type=str, default=None, help='plugin manifest')
        parser_node.add_argument('-pu', '--puuid', type=str, default=None, help='plugin uuid')



        ## NETWORK CMD
        parser_network = subparsers.add_parser('network')
        network_grp = parser_network.add_mutually_exclusive_group(required=True)

        network_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        network_grp.add_argument('-a','--add', action='store_true', help='add network')
        network_grp.add_argument('-r','--remove', action='store_true', help='remove network')

        parser_network.add_argument('-m', '--manifest', type=str, default=None, help='network manifest')
        parser_network.add_argument('-nu', '--nuuid', type=str, default=None, help='network uuid')
        parser_network.add_argument('-u', '--uuid', type=str, default=None, help='node uuid')

        ## ENTITY CMD
        parser_entity = subparsers.add_parser('entity')
        entity_grp = parser_entity.add_mutually_exclusive_group(required=True)

        entity_grp.add_argument('list', nargs='?', type=bool, default=False, help='list all network')
        entity_grp.add_argument('-a', '--add', action='store_true', help='add entity')
        entity_grp.add_argument('-r', '--remove', action='store_true', help='remove entity')
        entity_grp.add_argument('--define', action='store_true', help='define entity')
        entity_grp.add_argument('--undefine', action='store_true', help='remove entity')
        entity_grp.add_argument('--configure', action='store_true', help='configure entity')
        entity_grp.add_argument('--clean', action='store_true', help='clean entity')
        entity_grp.add_argument('--run', action='store_true', help='run entity')
        entity_grp.add_argument('--stop', action='store_true', help='stop entity')
        entity_grp.add_argument('--pause', action='store_true', help='pause entity')
        entity_grp.add_argument('--resume', action='store_true', help='resume entity')
        entity_grp.add_argument('--migrate', action='store_true', help='migrate entity')

        parser_entity.add_argument('-m', '--manifest', type=str, default=None, help='entity manifest')
        parser_entity.add_argument('-eu', '--euuid', type=str, default=None, help='entity uuid')
        parser_entity.add_argument('-iu', '--iuuid', type=str, default=None, help='instance uuid')
        parser_entity.add_argument('-u', '--uuid', type=str, default=None, help='node uuid')
        parser_entity.add_argument('-du', '--duuid', type=str, default=None, help='destination node uuid')

        ## MANIFEST CMD
        parser_manifest = subparsers.add_parser('manifest')
        manifest_grp = parser_manifest.add_mutually_exclusive_group(required=True)
        manifest_grp.add_argument('-n', '--network', action='store_true', help='network manifest')
        manifest_grp.add_argument('-e', '--entity', action='store_true', help='entity manifest')
        manifest_grp.add_argument('-a', '--application', action='store_true', help='application manifest')
        parser_manifest.add_argument('manifest', type=str, default=None, help='manifest path')


        kwargs = vars(parser.parse_args())
        #print(kwargs)

        if kwargs['cmd'] == 'start':
            self.start(kwargs['plugins'], kwargs['verbose'], kwargs['daemon'])

        elif kwargs['cmd'] == 'manifest':
            type = ''
            if kwargs['network'] is True: type = 'network'
            if kwargs['entity'] is True: type = 'entity'
            if kwargs['application'] is True: type = 'application'
            self.manifest(type, kwargs['manifest'])

        else:
            self.__initialize()
            if kwargs['cmd'] == 'node':
                action = ''
                if kwargs['add'] is True: action = 'add'
                elif kwargs['remove'] is True: action = 'remove'
                self.node(kwargs['list'], kwargs['uuid'], kwargs['plugin'], action, kwargs['manifest'],
                          kwargs['puuid'],kwargs['info'])
                self.exit(0)
            elif kwargs['cmd'] == 'network':
                self.network(kwargs['list'],kwargs['uuid'], kwargs['add'], kwargs['remove'], kwargs['manifest'],
                             kwargs['nuuid'])
                self.exit(0)
            elif kwargs['cmd'] == 'entity':

                action = ''
                if kwargs['add'] is True: action = 'add'
                if kwargs['remove'] is True: action = 'remove'
                if kwargs['define'] is True: action = 'define'
                if kwargs['undefine'] is True: action = 'undefine'
                if kwargs['configure'] is True: action = 'configure'
                if kwargs['clean'] is True: action = 'clean'
                if kwargs['run'] is True: action = 'run'
                if kwargs['stop'] is True: action = 'stop'
                if kwargs['pause'] is True: action = 'pause'
                if kwargs['resume'] is True: action = 'resume'
                if kwargs['migrate'] is True: action = 'migrate'

                self.entity(kwargs['list'], action, kwargs['uuid'], kwargs['manifest'], kwargs['euuid'],
                            kwargs['iuuid'],kwargs['duuid'])

                self.exit(0)
            else:
                print('Error check your command line!!')
                exit(-1)


if __name__ == '__main__':
        c = FOSCli()
        c.main()