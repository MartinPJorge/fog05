#!/usr/local/bin/python3

import sys

from click import pass_obj, pass_context
from jsonschema import validate, ValidationError
from fog05.DStore import *
from fog05 import Schemas
import signal
from fog05.fosagent import FosAgent
import time
import uuid



class Fos(object):
    def __init__(self):
        self.uuid = str(uuid.uuid4())
        self.agent = None

    def __initialize(self):
        self.droot = "dfos://<sys-id>"
        self.dhome = str("dfos://<sys-id>/%s" % self.uuid)
        self.dstore = DStore(self.uuid, self.droot, self.dhome, 1024)

        self.aroot = "afos://<sys-id>"
        self.ahome = str("afos://<sys-id>/%s" % self.uuid)
        self.astore = DStore(self.uuid, self.aroot, self.ahome, 1024)

        self.nodes = {}

        #uri = str('afos://<sys-id>/*/')
        #self.astore.observe(uri, self.nodeDiscovered)

    def print_nodes(self):
        uri = str('afos://<sys-id>/*/')
        nodes = json.loads(self.astore.get(uri))
        print(nodes)

    def __catch_signal(self,signal, frame):
        if signal == 2:
            if self.agent is not None:
                self.agent.stop()
            exit(0)

    def __start_node(self, plugin_path):
        signal.signal(signal.SIGINT, self.__catch_signal)
        self.agent = FosAgent(plugins_path=plugin_path)
        self.agent.run()
        while True:
            time.sleep(100)

    def __read_file(self, file_path):
        with open(file_path, 'r') as f:
            data = f.read()
        return data

    def __entry_point(self, action):
        r = {
            'node': self.__node_command,
            'network': self.__network_command,
            'entity': self.__entity_command,
            'application': self.__application_command
        }

        return r.get(action, None)

    def __node_plugins_list(self,node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        plugins = self.astore.get(uri)
        if plugins is not None:
            plugins = json.loads(plugins[0]).get('plugins')
            print('+-----------------------PLUGINS-------------------------+')
            for p in plugins:
                print('+-------------------------------------------------------+')
                print("| Name %s" % p.get('name'))
                print("| UUID %s" % p.get('uuid'))
                print("| Type %s" % p.get('type'))
            print('+-------------------------------------------------------+')
        else:
            print("No node or plugins found")

    def __send_add_plugin(self,node_uuid, name, type):
        val = {'plugins': [{'name': name, 'version': 1, 'uuid': '',
                            'type': type, 'status': 'add'}]}
        uri = str('dfos://<sys-id>/%s/plugins' % node_uuid)
        print(uri)
        # print(self.dstore.get(uri))

        r = self.dstore.dput(uri, json.dumps(val)) ### destination says:
        # >> Received old version of dfos://<sys-id>/e2b94d56-f4e1-99fa-886e-c1e3124496f9/plugins
        if r is None:
            print("Resolved failed")
        elif r:
            print("Plugin added")

    def __node_command(self, parameters):
        # TODO return None even if there are nodes in the system
        if len(parameters) < 2:
            print("Should specify node UUID or list")
            return
        if len(parameters) == 2:
            if parameters[1] == 'list':
                uri = str('afos://<sys-id>/*/')
                print(uri)
                nodes = self.astore.get(uri)[0]  ## se below for information on this
                ## this not work
                print(nodes)
            else:
                uri = str('afos://<sys-id>/%s/' % parameters[1])  ## this is because the resolver return a tuple with
                # value and version
                print("Uri: %s" % uri)
                node = self.astore.get(uri)
                if node is not None and len(node) > 0:
                    node = json.loads(node[0])
                    print('+-------------------------------------------------------+')
                    print('| UUID : %s \t\t|' % node.get('uuid'))
                    print('| Name: %s \t\t|' % node.get('name'))
                    print('+-------------------------------------------------------+')
                else:
                    print("Node not found!!")
                return
        if len(parameters) == 3:
            if parameters[2] == 'status':
                print('Should get the nodes status (cpu/ram ecc....')
                return
            if parameters[2] == 'info':
                uri = str('afos://<sys-id>/%s/' % parameters[1])
                node = self.astore.get(uri)
                if node is not None and len(node) > 0:
                    node = json.loads(node[0])
                    print('+-------------------------------------------------------+')
                    print('| UUID : %s \t\t|' % node.get('uuid'))
                    print('| Name: %s \t\t|' % node.get('name'))
                    print('+------------------------CPU----------------------------+')
                    cpus = node.get('cpu')
                    print('| Total CPU %d' % len(cpus))
                    for cpu in cpus:
                        print('+-------------------------------------------------------+')
                        print('| ARCH: %s' % cpu.get('arch'))
                        print('| Model: %s' % cpu.get('model'))
                        print('| Frequency: %s' % cpu.get('frequency'))
                    print('+-------------------------------------------------------+')
                    print('| RAM: %d' % node.get('ram').get('size'))

                    print('+----------------------NETWORKS-------------------------+')
                    nws = node.get("network")
                    for nw in nws:
                        print('| ################################################### |')
                        intf_conf = nw.get('inft_configuration')
                        print("| ## Interface: %s ##" % nw.get('intf_name'))
                        print("| ### MAC: %s " % nw.get('intf_mac_address'))
                        print("| ### type: %s " % nw.get('type'))
                        print("| ##### Interface Configuration #####")
                        print("| ###### Speed: %s " % intf_conf.get('intf_speed'))
                        print("| ###### IPV4: %s Netmask: %s Gateway: %s" % (intf_conf.get('ipv4_address'),
                              intf_conf.get('ipv4_netmask'), intf_conf.get('ipv4_gateway')))
                        print("| ###### IPV6: %s Netmask: %s" %
                              (intf_conf.get('ipv6_address'), intf_conf.get('ipv6_netmask')))
                    print('| ################################################### |')

                    accs = node.get('accelerator')
                    if accs is not None:
                        print('+----------------------ACCELERATORS-------------------------+')
                        for acc in accs:
                            print('| ################################################### |')
                            print("| ## Name: %s ##" % acc.get('name'))
                            print("| ## HW Address: %s ##" % acc.get('hw_address'))
                            print("| ## Supported libraries: %s ##"
                                  % ' '.join(acc.get('supported_library')))
                        print('| ################################################### |')
                    ios = node.get('io')
                    if ios is not None:
                        print('+----------------------I\O-----------------------------+')
                        for io in ios:
                            print('| ################################################### |')
                            print("| ## Name: %s ##" % io.get('io_type'))
                            print("| ## Type: %s ##" % io.get('hw_address'))
                            print("| ## File: %s ##" % io.get('io_file'))
                        print('| ################################################### |')
                    print('+-------------------------------------------------------+')
                else:
                    print("Node not found")
                return
        if len(parameters) > 3:
            if parameters[2] == 'plugins':
                if parameters[3] == 'list':
                    self.__node_plugins_list(parameters[1])
                    return
                elif parameters[3] == 'add':
                    # should specify name and type (or maybe uuid and then the command will resolve
                    if len(parameters) == 6:
                        plugin_name = parameters[4]
                        plugin_type = parameters[5]
                        if plugin_type in ['network', 'runtime']:
                            self.__send_add_plugin(parameters[1],plugin_name,plugin_type)
                            return
                        else:
                            print("Type %s not supported" % plugin_type)
                            return
                    else:
                        print("Should specify plugin name and type [network|runtime]")
                        return

    def __network_command(self, parameters):
        #network_schema = json.loads(self.__read_file('/home/ubuntu/FogOS/json_objects/network_define.schema'))
        network_schema = Schemas.network_schema

        if len(parameters) == 3:
            if parameters[1] == 'add':
                manifest = json.loads(self.__read_file(parameters[2]))
                try:
                    validate(manifest, network_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")
        ##################### with specified node uuid ########################
        if len(parameters) == 4:
            if parameters[1] == 'add':
                manifest = json.loads(self.__read_file(parameters[2]))
                try:
                    validate(manifest, network_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")
                node_uuid = parameters[3]
                self.__send_add_network(node_uuid, manifest)
        ########################################################################

    def __search_plugin_by_name(self, name, node_uuid):
        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        all_plugins = self.astore.get(uri)
        if all_plugins is None:
            print("Cannot get plugin")
            return None
        all_plugins = all_plugins[0]
        all_plugins = json.loads(all_plugins).get('plugins')
        search = [x for x in all_plugins if name in x.get('name')]
        if len(search) == 0:
            return None
        else:
            return search[0]


    def __send_add_network(self,node_uuid, manifest):

        uri = str('afos://<sys-id>/%s/plugins' % node_uuid)
        all_plugins = json.loads(self.astore.get(uri)).get('plugins')
        print(all_plugins)
        nws = [x for x in all_plugins if x.get('type') == 'network']
        if len(nws) == 0:
            print("No network plugin loaded on node, aborting")
            return
        brctl = nws[0]  # will use the first plugin

        uri = str('dfos://<sys-id>/%s/plugins' % node_uuid)
        print(uri)

        json_data = json.dumps(manifest)
        uri = str('dfos://<sys-id>/%s/network/%s/networks/%s' %
                  (node_uuid, brctl.get('uuid'), manifest.get('uuid')))
        r = self.dstore.put(uri, json_data)
        if r is None:
            print("Resolved failed")
        elif r:
            print("network added")

    def __send_add_entity(self, node_uuid, manifest):

        handler = None
        t = manifest.get('type')

        try:
            if t == "vm":
                handler = self.__search_plugin_by_name('KVM', node_uuid)
                validate(manifest.get("entity_data"), Schemas.vm_schema)
            elif t == "container":
                handler = self.__search_plugin_by_name('LXD', node_uuid)
                validate(manifest.get("entity_data"), Schemas.container_schema)
            elif t == "native":
                handler = self.__search_plugin_by_name('native', node_uuid)
                validate(manifest.get("entity_data"), Schemas.native_schema)
            elif t == "ros2":
                handler = self.__search_plugin_by_name('ros2', node_uuid)
                validate(manifest.get("entity_data"), Schemas.ros2_schema)
            elif t == "usvc":
                print("microservice not yet")
            else:
                print("type not recognized")

            if handler is None:
                print("error on plugin for this type of entity")
                return False
        except ValidationError as ve:
            print("Manifest is not correct")
            print("%s" % ve.message)
            return False

        entity_uuid = manifest.get("uuid")
        entity_definition = manifest
        json_data = json.dumps(entity_definition)
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s' % (node_uuid, handler.get('uuid'), entity_uuid))
        self.dstore.put(uri, json_data)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler.get('uuid'), entity_uuid))
            entity_info = json.loads(self.astore.get(uri))
            if entity_info is not None and entity_info.get("status") == "defined":
                break
        uri = str(
            'dfos://<sys-id>/%s/runtime/%s/entity/%s#status=configure' % (node_uuid, handler.get('uuid'), entity_uuid))
        self.dstore.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler.get('uuid'), entity_uuid))
            entity_info = json.loads(self.astore.get(uri))
            if entity_info is not None and entity_info.get("status") == "configured":
                break
        uri = str('dfos://<sys-id>/%s/runtime/%s/entity/%s#status=run' % (node_uuid, handler.get('uuid'), entity_uuid))
        self.dstore.dput(uri)
        while True:
            time.sleep(1)
            uri = str("afos://<sys-id>/%s/runtime/%s/entity/%s" % (node_uuid, handler.get('uuid'), entity_uuid))
            entity_info = json.loads(self.astore.get(uri))
            if entity_info is not None and entity_info.get("status") == "run":
                break

        return True

    def __entity_command(self, parameters):
        entity_schema = Schemas.entity_schema
        if len(parameters) == 3:
            if parameters[1] == 'add':
                manifest = json.loads(self.__read_file(parameters[2]))
                try:
                    validate(manifest, entity_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")

        ##################### with specified node uuid ########################
        if len(parameters) == 4:
            if parameters[1] == 'add':
                manifest = json.loads(self.__read_file(parameters[2]))
                try:
                    validate(manifest, entity_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")
                node_uuid = parameters[3]
                self.__send_add_entity(node_uuid, manifest)
            if parameters[1] == 'migrate':
                dst_node = parameters[3]
                entity_uuid = parameters[2]
                # TODO: should get the current node of the entity
        ########################################################################


    def __application_command(self, parameters):
        app_schema = Schemas.app_schema
        if len(parameters) == 3:
            if parameters[1] == 'add':
                manifest = json.loads(self.__read_file(parameters[2]))
                try:
                    validate(manifest, app_schema)
                except ValidationError as ve:
                    print("Manifest is not correct")
                    print("%s" % ve.message)
                    return
                print("manifest Ok")

    def main(self, argv):


        '''
        
        This is the entry point of the fog05 cli interface
        with this you can onboard application/entities, get information about current nodes in the system
        create virtual networks, and interact with entities
        
        @GB I think at least system id should be always specified or can be read from a simple conf.ini file
        
        usage:

        ---------
        fos node list
            list of nodes in current system

        fos node <node_uuid>
            get information about a specific node

        fos node <node_uuid> info
            get detailed information about a specific node

        fos node <node_uuid> status
            get status information about a specific node

        fos node <node_uuid> plugins list
             list of plugins in the specified node

        fos node <node_uuid> plugins add <name> [network,runtime]
            add a plugin to the node


        ---------
        fos network list 
            list of networks in current system
        
        fos network add <path to network json manifest>
            create a new network in the system

            @GB just for test the command accept a node_uuid to create a network on the node

        fos network remove <uuid>
            remove the specified network
        ---------

        @GB networks should be system-wide, this means that is a new node join should create all existing networks
        and when a new networks is added should be added to all nodes


        ---------
        fos entity list
            list of entity in current system
        
        fos entity add <path to entity json manifest>
            create a new entity in the system

             @GB just for test the command accept a node_uuid to deploy the entity on the node
 
        fos entity remove <uuid>
            remove the specified entity from the system
        
        fos entity migrate <uuid> <destination_uuid>
            migrate the entity to the destination uuid specified node
        --------
        
        --------
        fos application list
            list of applications in current system

        fos application <uuid> tree
            all info about components of the application, tree way
        
        fos application add <path to application json manifest>
            add an application in the current system
        
        fos application remove <uuid>
            remove the specified application from the system
        
        -------

        fos start <plugin path>
            will start a node, UUID is loaded by the os plugin

        -------


        '''

        if argv[1] == 'start':
            if len(argv) < 3:
                print("You should specify plugin path!!")
                exit(-1)
            else:
                sys.path.append(os.path.abspath(argv[2]))
                self.__start_node(argv[2])

        action = self.__entry_point(argv[1])
        if action is None:
            print("Error parameter %s not recognized" % argv[1])
        else:
            self.__initialize()
            time.sleep(5)
            action(argv[1:])


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("provide parameters")
    else:
        c = Fos()
        c.main(sys.argv)
